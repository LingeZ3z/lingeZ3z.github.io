<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串·SA</title>
      <link href="/2024/04/17/algorithm/string/sa/"/>
      <url>/2024/04/17/algorithm/string/sa/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>我们现在有一个长为 $n$ 的字符串 $s$，我们定义这个字符串的后缀 $i$ 表示 $s[i,n]$。</p><p>现在，我们要对 $s$ 所产生的 $n$ 个后缀进行排序，得到第 $i$ 个后缀是第几名，我们记其为 $rk_i$。同时，我们还能得到第 $i$ 名的是哪个后缀，记为 $sa_i$。</p><h1>如何求 SA</h1><h3 id="暴力">暴力</h3><p>我们有一种极其暴力的做法，把这 $n$ 个后缀存下来，再排序。总共有 $O(n\log n)$ 次比较，每次比较最坏 $O(n)$，则复杂度是 $O(n^2\log n)$，遥遥落后。</p><h3 id="倍增法">倍增法</h3><p>我们换一种思路：每次计算长度为 $w$ 的所有子串的排名，这样就可以通过合并排名来统计答案，为此，我们修改一下定义：</p><p>假设当前考虑的子串长度为 $w$，对于在结尾不足 $w$ 位的子串，我们给它补上当前字符集中最小的字符（实现中是值 $0$）。这样，我们就一共有 $n$ 个长为 $w$ 的子串了。</p><p>$rk_i$ 表示 $s[i,i+w-1]$ 在这 $n$ 个长为 $w$ 的子串中的排名。$sa_i$ 类似。</p><p>我们从 $w=1$ 的情况开始考虑。此时显然我们可以轻而易举地计算出 $rk_i$，然后根据 $rk$ 来计算 $sa$。</p><p>当我们考虑到 $w=2^p$ 时，假设我们已经有了 $w’=2^{p-1}$ 时的 $rk$ 和 $sa$。因为 $s[i,i+w-1]=s[i,i+w’-1]+s[i+w’,i+w-1]$，所以我们可以根据 $rk_i$ 和 $rk_{i+w’}$ 来进行一个排序。</p><p>先放一下代码，结合代码讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> w,rk[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[x]==rk[y])<span class="keyword">return</span> rk[x+w]&lt;rk[y+w];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> rk[x]&lt;rk[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">getline</span>(s+<span class="number">1</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sa[i]=i,rk[i]=s[i];</span><br><span class="line"><span class="keyword">for</span>(w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">sort</span>(sa+<span class="number">1</span>,sa+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在上面的这个实现中，最外层 for 循环开始时，$rk$ 的值就是子串长度为 $w$ 的值，而 $sa$ 的值是子串长度为 $w/2$ 的时候的值。每次 for 循环，先根据当前的 $rk$ 来把 $sa$ 更新到当前状态，再根据 $sa$ 计算出下一个 $rk$。</p><p>根据 $rk$ 来给 $sa$ 排序时（也就是 sort 函数），我们以 $rk_{sa_i}$ 为第一关键字，$rk_{sa_i+w}$ 为第二关键字。因为在子串 $s[sa_i,sa_i+2w]$ 中，根据字符串比较的原则，先比前面的 $s[sa_i,sa_i+w]$ 的部分。</p><p>后面根据 $sa$ 来更新 $rk$ 时，注意当两个子串相等时他们的 $rk$ 也要相等。</p><p>倍增 $O(\log n)$，排序 $O(n\log n)$，总时间复杂度 $O(n\log^2n)$。</p><h1>基数排序优化</h1><p>在给 $sa$ 排序的过程中，我们可以使用基数排序来优化到 $O(n)$ 排序。</p><p>首先我们要了解基数排序，而我们所使用的基数排序又依赖于计数排序，所以我们先讲讲计数排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[a[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)ans[i]=cnt[a[i]]--;</span><br></pre></td></tr></table></figure><p>十分的简洁明了。其中 $a$ 是待排序数组，$m$ 是值域，$ans_i$ 表示 $a_i$ 的排名。值得注意的是，这是一个稳定的排序算法，因为统计答案的时候我们采用了原数组倒序的方式。如果 $m=n$，那么 $ans$ 就是排序之后的答案数组。时间复杂度显然是 $O(n+m)$。</p><p>下面我们介绍一下基数排序。这是一个多关键字的排序，我们现在有 $n$ 个元素，每个元素有 $2$ 个关键字。$a_i$ 表示第 $i$ 个元素的第 $1$ 个关键字，$b_i$ 是第二个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[b[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)tmp[i]=cnt[b[i]]--;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[tmp[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)ans[i]=cnt[tmp[i]]--;</span><br></pre></td></tr></table></figure><p>为什么这样是正确的呢？第一次我们先对第二关键字排序。第二次排序的时候，当第一关键字不同，此时可以被正确排序。而当第一关键字不同的时候，因为计数排序是稳定的排序，所以我们原先保留的第二关键字的顺序不会变，就完成了排序。</p><p>把这项技术运用到我们的倍增法里，我们就得到了一个 $O(n\log n)$ 的求后缀数组的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,rk[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>],oldsa[N*<span class="number">2</span>],cnt[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">getline</span>(s+<span class="number">1</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">128</span>;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[i]]--]=i;</span><br><span class="line"><span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i<span class="number">-1</span>]]==oldrk[sa[i]])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="built_in">memcpy</span>(oldsa,sa,<span class="built_in">sizeof</span>(sa));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[oldsa[i]+w]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[oldsa[i]+w]]--]=oldsa[i];</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="built_in">memcpy</span>(oldsa,sa,<span class="built_in">sizeof</span>(sa));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[oldsa[i]]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[oldsa[i]]]--]=oldsa[i];</span><br><span class="line"><span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graphviz 图论画图工具笔记</title>
      <link href="/2024/04/12/graphviz/"/>
      <url>/2024/04/12/graphviz/</url>
      
        <content type="html"><![CDATA[<h1>简介</h1><p>如题，是一个可以便捷生成图论中各种图的工具。</p><h1>下载 &amp; 安装</h1><p><a href="https://graphviz.org/download/">链接</a></p><p>自己选适合自己操作系统的版本。</p><p>安装以 Windows 为例，其实也没什么要注意的点，把 “Add Graphviz to the system PATH” 中的任意一个勾上就行了。</p><p>命令行试试 <code>dot -V</code>，如果有输出说明安装成功，没输出检查一下勾没勾上上述选项。</p><h1>配置</h1><p>以 VSCode 为例。</p><p>插件搜索 Graphviz，安装 Graphviz Interactive Preview 和 Graphviz (dot) language support for V。</p><p>前者是用于实时生成预览图，后者提供语法高亮。</p><h1>教程</h1><p>Graphviz 源文件的扩展名是 <code>.dot</code>。所以我们在 VSCode 中新建一个 <code>.dot</code> 文件。你会发现右上角有一个小图标，点开它，就有了预览界面。</p><p>先试着写一点简单的图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    A -&gt; B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>digraph</code> 定义了一个有向图，这个有向图里有 <code>A</code> 和 <code>B</code> 两个结点，其中 <code>A</code> 向 <code>B</code> 连了一条有向边。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    A [color = red, shape = box, style = dashed]</span><br><span class="line">    B [color = blue, shape = ellipse, style = bold]</span><br><span class="line">    A -&gt; B [label = &quot;A to B&quot;, color = red, style = dashed]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来一一解读一下。<br>第一行我们定义了一个有向图，这和上个示例一样。<br>第二行我们定义了一个结点 <code>A</code>，它有一些属性，如：红色，方形，虚线。<br>第三行我们定义了一个结点 <code>B</code>，它有一些属性，如：蓝色，椭圆形，加粗线。<br>第四行我们定义了一个有向边 <code>A -&gt; B</code>，它的附加文本是 <code>A to B</code>，其他同上。</p><p>详细的介绍可以参照<a href="https://www.graphviz.org/doc/info/attrs.html">官方文档</a>。</p><p>根据以上内容，我们可以轻松地写出来一个通过一些字符串来构建可视化 Trie 树的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> e[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line"><span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!t[p].e[c])t[p].e[c]=++tot;</span><br><span class="line">p=t[p].e[c];</span><br><span class="line">&#125;</span><br><span class="line">t[p].s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].e[i])&#123;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>&lt;&lt;t[p].e[i]&lt;&lt;<span class="string">&quot; [label = \&quot;&quot;</span>&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i)&lt;&lt;<span class="string">&quot;\&quot;]&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(t[p].e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;out.dot&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="built_in">insert</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;digraph&#123;&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line"><span class="keyword">if</span>(t[i].s)</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; [style = bold]&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于输出的文件，我们可以通过 <code>dot -Tpng 1.dot -o 1.png</code> 来把 <code>.dot</code> 文件转化成 <code>.png</code> 图片。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串·KMP</title>
      <link href="/2024/04/03/algorithm/string/kmp/"/>
      <url>/2024/04/03/algorithm/string/kmp/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><h2 id="约定记号">约定记号</h2><p>$s[l,r]$ 代表从 $l$ 到 $r$ 的子串。</p><h2 id="pi-函数">$\pi$ 函数</h2><p>对于一个字符串 $s$，它的 $\pi$ 函数是它的前缀和后缀相等的最长长度。</p><p>$$ \pi=\max_{s[1,i]=s[n-i+1,n]} i $$</p><p>进一步，我们定义 $\pi_i$ 是字符串前 $i$ 个字符组成的子串的 $\pi$ 函数值。特别的，定义 $\pi_1 =0$。</p><p>下面我们考虑如何求出 $\pi$ 数组。</p><p>对于 $\pi_1=0$ 是确定的，考虑递推。</p><p>假设我们当前求出了 $\pi_1,\pi_2,\cdots,\pi_i$ 要求出 $\pi_{i+1}$。</p><p>有一个特殊情况，如果 $s[\pi_i+1]=s[i+1]$，那么 $pi_{i+1}=\pi_i+1$。</p><p>根据 $\pi$ 函数定义，$s[1,\pi_i]=s[i-\pi_i+1,i]$，那么如果 $s[\pi_i+1]=s[i+1]$，就有了 $s[1,\pi_i+1]=s[i-\pi_i+1,i+1]$，进而有 $\pi_{i+1}=\pi_i+1$。</p><p>下面考虑当 $s[i+1]\ne s[\pi_i+1]$ 时的情况：</p><p>还是一样的，$s[1,\pi_i]=s[i-\pi_i+1,i]$，$\pi_{i+1}$ 肯定不比 $\pi_i$ 大，所以我们要在 $[1,\pi_i]$ 中找到一个最大的 $j$ 使得 $s[i-j+1,i+1]=s[1,j+1]$，此时 $\pi_{i+1}=j+1$。</p><p>注意到此时 $s[1,j]$ 是 $s[1,\pi_i]$ 的前缀，$s[i-j+1,i]$ 是 $s[i-\pi_i+1,i]$ 的后缀，又因为 $s[1,\pi_i]=s[i-\pi_i+1,i]$，所以 $[i-j+1,i]$ 是 $s[1,\pi_i]$ 的后缀。</p><p>当满足 $s[i-j+1,i+1]=s[1,j+1]$ 且 $j$ 最大时，也就是 $s[1,\pi_i]$ 的前缀和后缀相等且长度最长的时候，我们发现此时正好和 $\pi$ 的定义对上了，那么此时的 $j$ 就是 $\pi_{\pi_i}$。</p><p>若此时 $s[j+1]=s[i+1]$，那么 $\pi_{i+1}=j+1$。否则一直这么找下去，直到真的没有相同的前后缀。</p><p>求 $\pi$ 数组代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=pi[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])j++;</span><br><span class="line">    pi[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP-算法">KMP 算法</h2><p>该算法用于解决这样的问题：</p><p>给定文本串 $s$ 和模式串 $t$，求 $s$ 中所有出现的 $t$ 的位置。</p><p>我们可以使用这样的方法来解决：令 $f=s+c+t$，其中 $c$ 是不属于字符集的一个字符，求 $f$ 的 $\pi$ 数组，若 $\pi_i=len_t$，则在以 $i$ 为结尾的位置匹配上了。代码略。</p><p>另外还有一种不用显式建出字符串 $f$ 的方法：我们先跑出 $t$ 的 $\pi$ 数组，然后直接匹配，过程类似于求 $\pi$ 数组，具体见代码，其中 $mth_i$ 表示到 $s_i$ 匹配了多少位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=mth[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;t[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">    <span class="keyword">if</span>(t[j+<span class="number">1</span>]==s[i])j++;</span><br><span class="line">    mth[i]=j;</span><br><span class="line">    <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">        <span class="comment">// 此时匹配上了</span></span><br><span class="line">        j=pi[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>联合省选2024·游记</title>
      <link href="/2024/04/02/article/lhsx2024/"/>
      <url>/2024/04/02/article/lhsx2024/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>关于 CSP 没什么好说的，A 切了，B 35pts 暴力之后跑路。</p><p>C 一看，第一次遇见大模拟，有点害怕，草草写了个 15pts 性质分跑路了，然后一直在做 D 题。</p><p>总之就是很飞舞，D 题暴力挂了，C 挂了 10 pts，最后只有 140 分。</p><p>压线 6 级勾，有点惊喜但不多，可以参加 NOIP。</p><h3 id="NOIP"><a href="#NOIP" class="headerlink" title="NOIP"></a>NOIP</h3><p>A 切了，B 看了之后有点害怕，以为是什么 Tarjan 图论题。</p><p>因为我 Tarjan 学得不好所以打了个部分分草草了事</p><p>我为什么没看见暴力分？我为什么没看见暴力分？我为什么没看见暴力分？</p><p>C 题更害怕，做了个特殊性质。</p><p>我为什么没看见暴力分？我为什么没看见暴力分？我为什么没看见暴力分？</p><p>D 题，是个 DP，感觉很可做诶，写了个 $O(n^2)$ DP，后面不会优化了，跑路。</p><p>最后只有 146 分，大失败，这也是为什么我在这之后的比赛基本不想正解，只打部分分。</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>是一个省选模拟赛。</p><p>上来看 A，什么抽象题面，转去看 B，发现有 59 分是送的，赶紧写了。</p><p>读了 A，暴力思维难度较大，于是看 C，发现有 21 分是送的，赶紧写了。</p><p>后面就是 A 和 C 交替进行，C 写了一个类似于分层图 + 双端队列 BFS 的东西但是复杂度假了。A 分析了一会感觉不会就摆了。</p><p>最后 80 分，大众分，对得起我的水平。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>依然是省选模拟赛，但是是 OI 赛制。</p><p>A 题奇怪数学题，开场 10 min 就有人说切了，有点害怕，后来乱猜了结论之后就过了。</p><p>B 题像 DP，糊了一个 $O(qn^3)$ DP，期望得分 19 分。</p><p>C 题像奇怪 DS 题，感觉很繁琐，而且暴力的 $O(n!)$ 不给过，于是思考特殊性质，但是不会，去看 B。</p><p>B 还是不会，去看 C，此时恍然大悟就开始写，结果最后没时间调了。</p><p>评测，A 没挂分，RP—，B甚至多得了17分，这下 RP 掉光了，C 没得分，最后是获得了我 OI 生涯的第一个 rk1，令人感慨。</p><p>最后发现 BC 都是 DP，吓人。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>此时我已经狂暴 whk 一周了，感觉很颓。又因为作业比较多，几乎没早睡过，比较困。晚上去试机有点晕车。</p><p>到达山师二附中，面到了 <a href="https://www.luogu.com.cn/user/679581">MrPython</a> 老师。很可爱，是 Linux 爷，但是他走错考场，于是就有了我们戏剧性相见的一幕。</p><p>面基完赶紧去考场，坐下之后不知道敲什么，看左边在敲一个不知道是什么的树上算法，右边在敲 Dinic，我就敲了一个树剖，结果发现挂了一个点，不想调了就没调。<br>发现老头、吴爷、豆、王老师都在一个考场，于是就去聊天。豆在测试快读快写和 cin cout 的速度差异，运用了控制变量法。</p><p>发现吴老师和 nrd 一个考场，想去看，但是太远了没去，只能羡慕 Linux 爷了。</p><p>回家看了看树剖为什么挂了，发现是取模问题，看了一个关于 pbds 的博客，转念一想不会出板子题，就没背。</p><p>明天准备罚坐，放张图片镇楼。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nhc1vva8.png" alt=""></p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上到了考场门口，先和各路大神交流一下，进考场之后基本在发呆。</p><p>公布密码之后先看题，A 抽象，B 抽象，C 更抽象。按照以往惯例我先开了 A。</p><p>推了下式子，发现 $\sum x_{i\bmod n}$ 可以 $O(1)$ 求，然后又发现最终答案和每个 $x’_i$ 的具体取值无关，于是想到了二分答案。</p><p>二分写完之后调样例，第二个死活调不过去，于是在大概十点半的时候放弃了，去看 B，发现 B 有 12 分是送的，赶紧写了，调了一会过了样例。</p><p>看 C，感觉题面极其抽象，而且要满足的限定条件很多，感觉写暴力有点不划算，回去调 A。</p><p>偶然的一个机会我输出了一个中间变量，发现我错的点都有一个明显的共同特征：二分域上只有一个点满足要求。进一步结合数据分析，发现此时 $x$ 正好是 $x_0$ 的倍数，于是开心写了个特判然后过了第二个样例。</p><p>第三个样例，麻烦，又有很多不对的地方。于是我拓展特判到了 $n&gt;1$ 的情况，此时码长来到了 3.5k，发现死活过不去。</p><p>调了半个小时，果断放弃了 A，去看 B 特殊性质。感觉像 01trie，但是我仅限于听过这个东西，用贪心打了个 B 性质，发现错的离谱，于是就放弃了。再去看 C 还是那么的抽象，于是又回去看 A 了。</p><p>开始一个个排查着样例里出错的测试点，前几个还好，是因为特判的边界情况，但是我突然发现了一个样例有点不对，定睛一看：</p><p>卧槽，原来是没有单调性的。</p><p>崩溃了。</p><p>保护了一下一些特殊性质分之后就摆了，C 决定输出 0，此时还剩 20 min。</p><p>还没出考场就去问别人 A 怎么做的，发现吴爷也是二分，王老师写的分讨但是没过，老头分讨把 A 切了。</p><p>下楼，听刘老师说就是分讨，而且蒋老师分讨接近切 A，拜谢/bx/se。</p><p>讨论了一路关于二分单调性的东西，最终豆得出结论：$k$ 较大时有单调性，较小时没有，我恍然大悟。</p><p>回家吃了饭，下午还得去学校团建，累。</p><p>回家估分。A 比我预期低十分，但是该得的分挂了，不该得的分得了。B 暴力拿到了。</p><p>一问，一车写了 BC 更多部分分的，我是 shaber。</p><p>十点被逼迫睡觉了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>希望别漏下性质分。</p><p>八点多到的考场，打了缺省源就开始睡觉。</p><p>公布密码。一看，A 疑似太疑似了，看到 $\sum n \leq 80$，暴力分都不给了？去看 BC 结果发现更抽象，于是回来写 A 的 A 性质，写了一会发现过了。</p><p>去看了 B，草草把 B 的前 5pts 写了，输出 1 然后跑路去 C。C 这题面就不想看，跑路回 A，发现 A 的纯暴力能过，就写了 A 暴力。</p><p>然后看 B 性质。先想了一个非常贪的东西，写出来发现不行，然后就对着样例调。优先队列改成枚举，枚举改成优先队列，贪心思路来来回回改了不下十遍，样例三总是有几个数不对，但是样例四过了，样例五过不了。</p><p>A 一直写到了 12:50。出考场问一下，只有蒋老师把 A 前四个样例切了，用的是树剖套树套树，害怕，然后发现 B 都写了 20pts，崩溃了。</p><p>回家后发现 A 是 DP，以后贪不对的时候记得想想 DP。</p><p>笑，估分，A 比保底得分多了 10pts，没白贪。</p><h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day inf"></a>Day inf</h1><p>出分。$40 + 12 + 0 + 50 + 10 = 112$。</p><p>感觉挺唐诗的，D1T1<br>与我预期挂了 20pts，D2T1 挂了 -10pts。</p><p>排名 70 多，不忍心看。</p><p>崩溃。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/2024/04/02/Introduction/"/>
      <url>/2024/04/02/Introduction/</url>
      
        <content type="html"><![CDATA[<h1>这是一个自我介绍</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2024/04/02/Test/"/>
      <url>/2024/04/02/Test/</url>
      
        <content type="html"><![CDATA[<h1>This is a testing article.</h1><p>$$ 若a,b&gt;0，则 a+b \ge 2\sqrt{ab} $$</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
