<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树的直径</title>
      <link href="/2024/05/07/algorithm/graph/diameter/"/>
      <url>/2024/05/07/algorithm/graph/diameter/</url>
      
        <content type="html"><![CDATA[<h1>树的直径</h1><h2 id="定义">定义</h2><p>所谓树的直径，就是树上一条最长的链。</p><p>注意到这条链不唯一。</p><p>我决定在讲解例子的过程中穿插性质。</p><h2 id="直径的求法">直径的求法</h2><h3 id="两次搜索">两次搜索</h3><p>引理：<strong>一棵树上以任意一个点开始的最长简单路径的终点一定是直径两个端点之一</strong>。</p><p>证明：</p><blockquote><p>若不是端点，可分为两种情况讨论：<br>第一种，这条路径不与直径相交，则让直径改道过来这条路径显然比原来的直径更长，矛盾。<br>第二种，这条路径与直径相交，则让直径在交点处顺着这条路径走显然比原来直径更长，矛盾。<br>得证。</p></blockquote><p>所以我们可以两次搜索。</p><p>第一次任选一个点当做起点，找到距离这个点最远的一个点，则这个点一定是直径的其中一个端点。</p><p>第二次再把这个端点当做起点，找到另一个端点。</p><p>这种方法的好处在于可以求具体方案。但是注意一棵树可能有多条直径，且这种方法不适用于负权边存在的情况。</p><h3 id="树形-DP">树形 DP</h3><p>在树形 DP 中，我们对于每个点维护两个值：在以这个点为根的子树中，从这个点往下走的链的最长长度和次长长度。转移直接由儿子的最长长度加上到儿子的边权即可。</p><p>直径就是每个点最长长度和次长长度加起来的最大值。</p><p>这种方法可以用于负权边情况。</p><h2 id="SDOI2011-消防（树网的核-加强版）">[SDOI2011] 消防（树网的核 加强版）</h2><p>题意不再赘述。</p><p>首先说说为什么这条路径肯定在直径上。我们只要证明当这条路径不在直径上的时候，不比在直径上更优即可。</p><blockquote><p>依然分两种情况。<br>首先，在这棵树上，存在一个点，使得它到直径两端的距离的最大值最小（也即到其他任何点的距离最大值最小）。这个点一定是在直径上的。<br>当这条路径完全不在直径上时，还不如直接选取这个点更优，而这个点的路径长度是 $0$，肯定比这个路径更优。<br>当这条路径有一部分在直径上时，直接把不在直径上的部分去掉，让它变成一条完全在直径上的路径，答案不会变。因为如果答案变了，说明把这条路径不在直径上的部分去掉后，路径的端点顺着原路径方向的距离最大值比到直径端点的距离长，与 “一棵树上以任意一个点开始的最长简单路径的终点一定是直径两个端点之一” 相矛盾。</p></blockquote><p>所以我们只需要考虑这条路径在直径上即可。</p><p>考虑对于一条直径上的路径，如何计算它到各点路径长度的最大值。</p><p>首先，这条路径的左右端点到直径的左右端点的距离可能成为最大值，这是显然的，而且我们不用考虑左右端点到除了直径端点以外的情况，因为 “一棵树上以任意一个点开始的最长简单路径的终点一定是直径两个端点之一”。</p><p>我们给直径做一个距离前缀和，就能快速求出来这个距离。</p><p>其次，路径上中间的每个点还可以往直径的侧边走，我们对于直径上每个点预处理出来往侧边走的最大值。</p><p>最后考虑如何维护路径。</p><p>我们使用双指针来维护 “路径长度不超过 $s$” 这一条件，用单调队列来维护路径上点往侧边走的最大值即可。最终 $O(n)$。</p><h1>树的半径</h1><p>还是挺重要的。</p><h2 id="定义-2">定义</h2><p>在一棵树中，找到一个点（中心）使得这个点到树的其他所有点的距离最大值最小，则这个最大值就是树的半径。</p><h2 id="求法">求法</h2><p>先用树形 DP 求直径把 $f_u,g_u$ 求出来。</p><p>定义 $h_u$ 为 $u$ 这个结点往上走的最大距离。转移考虑两种情况：$u$ 到父亲继续往上走，还是 $u$ 到父亲然后到 $u$ 的兄弟，两种情况取 $\max$ 即可。</p><p>半径就是所有 $\max\{f_u,h_u\}$ 的最小值。</p><h2 id="直径的合并">直径的合并</h2><p>挺有意思的。标题没打错，就是 <strong>直径</strong> 的合并。</p><p>对于两棵树，把它俩合并之后直径的长度最小是多少？</p><p>两种情况：</p><p>第一种情况，是原来两棵树的直径不变。</p><p>第二种情况，两棵树的中心连起来，最终的直径就是两棵树的半径和连起来这条边的边权加起来。</p><p>很显然，不多说了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流模型 · 最小路径覆盖 &amp; 拓展</title>
      <link href="/2024/04/26/algorithm/graph/flow/zxljfg/"/>
      <url>/2024/04/26/algorithm/graph/flow/zxljfg/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>在一个 DAG（有向无环图中），选择其中的一些简单路径，若图中每个点都恰好在其中一条路径上，则称这些路径是一个<strong>路径覆盖</strong>。</p><p>所有路径覆盖中，路径条数最小的路径覆盖叫做<strong>最小路径覆盖</strong>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/q46ij4r4.png" alt=""></p>例如在上图中，$\{\{1\},\{2,3\},\{4,5\}\}$ 是一个路径覆盖，$\{\{1,2,3,4,5\}\}$ 是一个最小路径覆盖，只用了一条路径。<p>任务是找出 DAG 上的最小路径覆盖，且输出方案。</p><h1>建模</h1><p>考虑二分图最大匹配。</p><p>我们对原图中每个点 $u$ 拆成两个点，记为左部点 $L(u)$ 和右部点 $R(u)$。</p><p>对于原图中每条边 $(u,v)$，连接 $L(u)$ 到 $R(v)$。</p><p>则答案为原图中点数减去最大匹配数。</p><h1>正确性</h1><p>假设开始时图上的每个点都自成一条路径，我们要做的是尽可能多地把路径合并。</p><p>考虑一下路径合并的隐藏条件：</p><p>首先，路径合并是可以传递的，简单来说，如果 $x$ 能跟 $y$ 合并，$y$ 能跟 $z$ 合并，那么 ${x,y,z}$ 可以合并成一条路径。所以我们可以只考虑点与点之间的合并关系，再利用传递性求方案。</p><p>其次，每条路径只能向一个路径合并，也只能被一条路径合并。</p><p>这下就好办了。在我们构造的二分图中，如果一条边 $(L(u),R(v))$ 被选中了，那么说明在原图中点 $u$ 要向点 $v$ 合并，同时其它在二分图中与其它 $L(u)$ 相连的边都不能被选中，对应着在原图中一个点仅能选择另外一个点进行合并。</p><p>此时的最大匹配就是可以合并的数量，用总的点数减去它就是答案。</p><p>至于方案数，可以根据上面所说的，用并查集简单维护即可。</p><p>二分图的最大匹配我们可以选择用最大流来求。跑完最大流后，如果一条连接 $L(u)$ 和 $R(v)$ 的边容量为 $0$，则说明这条边在二分图中被选中了。</p><h1>拓展 1 · 最小链覆盖</h1><p>所谓最小链覆盖，无非是把路径改为了链。对应的，DAG 上的每一个点可以被重复覆盖多次。</p><p>此时我们对 DAG 用 Floyd 进行传递闭包，得出每个点相互可不可达，再根据这个跑最小路径覆盖即可。</p><h1>拓展 2 · DAG 最大独立集</h1><p>顾名思义，我们要在 DAG 中选取一些点，使得任意两个点都不能从其中一个点到另外一个。</p><p>此时我们引入偏序集。</p><h2 id="偏序集">偏序集</h2><h3 id="偏序集和偏序关系">偏序集和偏序关系</h3><p>我当然不会上来就放形式化的东西，否则你们还有什么来看的必要呢？</p><p>所谓偏序集，指的是一个集合和一个关系的共同体。</p><p>那么何为关系？举个最简单的例子，“$\leq$”（小于等于号）是一个关系。</p><p>现在我们给偏序集做一个定义，百度说：</p><blockquote><p>若在集合 $A$ 上给定一个偏序关系 $\leq$ ，则称集合 $A$ 按偏序关系 $\leq$ 构成一个偏序集合，集合 $A$ 和偏序 $\leq$ 一起称为偏序集，记作 $(A,\leq)$。</p></blockquote><p>不懂。什么是偏序关系？</p><blockquote><p>设 $R$ 是集合 $A$ 上的一个关系，如果 $R$ 是<strong>自反的</strong>、<strong>反对称</strong>的和<strong>可传递</strong>的，则称 $R$ 是集合 $A$ 的偏序关系，简称偏序，记作“$\leq$”。</p></blockquote><p>现在对偏序关系中的一些名词做一些解释：</p><p>自反：$\forall a\in A,a\leq a$</p><p>反对称：$\forall a,b\in A, $ 若 $a\leq b$ 且 $ b\leq a,$ 则 $a=b$</p><p>传递性：$\forall a,b,c\in A,  $若$ a\leq b $且$ b\leq c, $则$ a\leq c$</p><p>不妨把这个小于等于号真的当做一个小于等于号来看待，则 $\leq$ 是 $\mathbb{R}$ 的偏序关系。</p><p>所以我们可以说 $(\mathbb{R},\leq)$ 是一个偏序集。</p><h3 id="元素之间的可比关系">元素之间的可比关系</h3><p>设 $(P,\leq)$ 是一个偏序集。</p><p>$a,b\in P$，若 $a\leq b$ 或 $b\leq a$，则我们称 $a$ 与 $b$ 是可比的。无需解释。</p><p>否则我们说 $a$ 与 $b$ 不可比，记作 $a\mid\mid b$。</p><h3 id="延伸">延伸</h3><p>设 $(P,\leq)$ 是一个偏序集，$\geq$ 是一个关系。</p><p>若对于 $\forall x,y\in P$，有 $x\leq y \Leftrightarrow y\geq x$，则我们称 $\geq$ 是 $\leq$ 的逆关系，记作 $\leq^{-1}$。$\leq^{-1}$ 是 $\leq$ 的逆。无需解释，符号已经说的很明白了。</p><p>那么，若 $(A,\leq)$ 是一个偏序集，$(A,\leq^{-1})$ 也是一个偏序集。这是显然的。$(A,\leq^{-1})$ 称作 $(A,\leq)$ 的对偶，简记作 $A^{-1}$。</p><h3 id="偏序集的哈塞图">偏序集的哈塞图</h3><p>所谓哈塞图，不如将其理解为一个 DAG。</p><p>设 $(P,\leq)$ 是一个偏序集，我们对于 $\forall a,b(a\neq b)\in P,$ 若 $a\leq b$ 则从 $b$ 到 $a$ 连一条边，最后显然会形成一个 DAG。（根据传递性可得到图中没有环）</p><h3 id="链、反链、Dilworth-定理">链、反链、Dilworth 定理</h3><p>偏序集 $(P,\leq)$ 上的一个链是一个元素集合 $S \subset P$，其中 $\forall a,b\in S,a$ 与 $b$ 可比。</p><p>反链就是反着来，也是一个元素集合 $S\subset P$ 其中 $\forall a,b\in S,a\mid\mid b$。</p><p>需要注意的是，链在 DAG 中并不是一条路径，而是一条路径上可以不连续的几个点，但是在后续我们为了方便，把链看成 DAG 上的一条路径，反链就是一些 DAG 上互相不可达的点。</p><p>接下来我们引入偏序集的链划分。</p><p>所谓链划分，就是一些链的集合，使得偏序集的每一个元素都在其中至少一条链上。</p><p>最小链划分就是用最少的链来把整个偏序集覆盖，对应到 DAG 上就是最小链覆盖。</p><p>Dilworth 定理指出，<strong>偏序集中的最长反链长度等于最小链划分个数</strong>。</p><p>证明略，感兴趣的可以尝试对偏序集的大小进行归纳证明。</p><h2 id="模型">模型</h2><p>看到这里是不是恍然大悟了，我们在原 DAG 上求最小链覆盖，得到的答案就是最大独立集大小。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流模型 · 最大权闭合子图</title>
      <link href="/2024/04/25/algorithm/graph/flow/zdqbhzt/"/>
      <url>/2024/04/25/algorithm/graph/flow/zdqbhzt/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>我们先来定义什么是闭合子图。</p><p>通俗地讲，在一个有向图中，我们选择一些点作为一个点集。若这个点集中任何一个点所能到达的所有点都在这个点集中，我们称这个点集是一个<strong>闭合子图</strong>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/q46ij4r4.png" alt=""></p><p>例如，在上图中，$\{5\},\{2,3,4,5\},\{1,2,3,4,5\}$ 都是这个图的闭合子图。而 $\{2,4,5\}$ 则不是，因为 $3$ 可以到达 $4$，而 $4$ 不在这个点集中。</p><p>现在，每个点有一个点权 $w_i$，$w_i$ 可以是负数，我们要选择一个<strong>最大权闭合子图</strong> $S$ 来最大化 $\sum_{u\in S}w_u$，即选择一个点权和最大的闭合子图。</p><h1>建模方法</h1><p>我们考虑把它转化成网络流中的最小割来解决。</p><p>具体地，建立超级源点 $S$ 和超级汇点 $T$。</p><ol><li><p>对于原图中的边，我们保留，并把其容量设为 $\inf$。</p></li><li><p>对于每个原图中的点 $u$：若 $w_u&gt;0$ 则从 $S$ 向 $u$ 连一条容量为 $w_u$ 的边。若 $w_u&lt;0$ 则从 $u$ 向 $T$ 连一条容量为 $-w_u$ 的边。若 $w_u=0$，我们不管他。（也可以管，但是容量为 $0$ 就相当于没有边）</p></li><li><p>我们跑出这个网络的最小割，其容量记为 $c$，则最大权闭合子图的权值和就是 $\sum_{w_u&gt;0}w_u-c$。</p></li></ol><h1>正确性</h1><p>首先，最小割一定不会割掉原图中的边，因为这些边的容量是 $\inf$，割掉它还不如把其它所有边割掉。</p><p>其次，我们是不会主动选择一个负权点 $u$ 的。若选择了这个点，则其在原图中所有能到达的点都被选择了，那还不如选择 $u$ 的所有儿子而不选择 $u$ 更优。</p><p>如果我们割掉了一条从 $S$ 到正权点 $u$ 的边，则说明我们不选择 $u$。</p><p>如果我们割掉了一条从负权点 $v$ 到 $T$ 的边，则说明我们选择 $v$。</p><p>每个点都只有选或者不选两种情况，所以，<strong>一个割一定对应一个子图</strong>。</p><p>对于一条从 $S$ 连向正权点 $u$ 的边，若不割掉它，则说明我们选择了原图中 $u$ 这个点，进而选择了 $u$ 的所有能到达的点 $V$。$V$ 中如果有负权点，那么必须割掉这些负权点到 $T$ 的边（也即选择这些负权点），否则存在从 $S$ 到 $T$ 的路径，不能形成一个割。</p><p>所以，<strong>一个割一定对应一个闭合子图</strong>。</p><p>对于一条从 $S$ 连向正权点 $u$ 的边，若不割掉它，则说明我们选择了原图中 $u$ 这个点，进而选择了 $u$ 的所有能到达的点 $V$。$V$ 中如果有正权点，则 $S$ 到这些点的边一定不会割掉（对应着我们选择了这些点），因为在割掉 $V$ 中所有负权点到 $T$ 的边的前提下，这些点不用割掉任何其它的负权点到 $T$ 的边，因此不割肯定比割了要更优。</p><p>若对于一个负权点 $v$，其所有的前驱正权点到 $S$ 的边都被割掉了，那么就不用割掉 $v$ 到 $T$ 的边了，因为显然没有任何点能选择 $v$。</p><p>以上的这些只是为了加深理解，<strong>最小割一定对应最大权闭合子图</strong>。</p><p>最后，答案是 $\sum_{w_u&gt;0}w_u-c$ 的原因也就呼之欲出了：</p><p>$c$ 中包含了 $S$ 到正权点的边的容量，即不选这个正权点，所以肯定要从正权点的和中减去。</p><p>同时它又包含了负权点到 $T$ 中的容量，即选择这个负权点，因为权值是负的，所以肯定要减去。（与前文 $w_u&lt;0$ 时边的容量设成 $-w_u$ 形成呼应）</p><p>关于具体方案，根据上文所说的 割不割 与 选不选 的关系可以轻松求得。</p><p>$$Q.E.D.$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串·SA</title>
      <link href="/2024/04/17/algorithm/string/sa/"/>
      <url>/2024/04/17/algorithm/string/sa/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>我们现在有一个长为 $n$ 的字符串 $s$，我们定义这个字符串的后缀 $i$ 表示 $s[i,n]$。</p><p>现在，我们要对 $s$ 所产生的 $n$ 个后缀进行排序，得到第 $i$ 个后缀是第几名，我们记其为 $rk_i$。同时，我们还能得到第 $i$ 名的是哪个后缀，记为 $sa_i$。</p><h1>如何求 SA</h1><h3 id="暴力">暴力</h3><p>我们有一种极其暴力的做法，把这 $n$ 个后缀存下来，再排序。总共有 $O(n\log n)$ 次比较，每次比较最坏 $O(n)$，则复杂度是 $O(n^2\log n)$，遥遥落后。</p><h3 id="倍增法">倍增法</h3><p>我们换一种思路：每次计算长度为 $w$ 的所有子串的排名，这样就可以通过合并排名来统计答案，为此，我们修改一下定义：</p><p>假设当前考虑的子串长度为 $w$，对于在结尾不足 $w$ 位的子串，我们给它补上当前字符集中最小的字符（实现中是值 $0$）。这样，我们就一共有 $n$ 个长为 $w$ 的子串了。</p><p>$rk_i$ 表示 $s[i,i+w-1]$ 在这 $n$ 个长为 $w$ 的子串中的排名。$sa_i$ 类似。</p><p>我们从 $w=1$ 的情况开始考虑。此时显然我们可以轻而易举地计算出 $rk_i$，然后根据 $rk$ 来计算 $sa$。</p><p>当我们考虑到 $w=2^p$ 时，假设我们已经有了 $w’=2^{p-1}$ 时的 $rk$ 和 $sa$。因为 $s[i,i+w-1]=s[i,i+w’-1]+s[i+w’,i+w-1]$，所以我们可以根据 $rk_i$ 和 $rk_{i+w’}$ 来进行一个排序。</p><p>先放一下代码，结合代码讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> w,rk[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[x]==rk[y])<span class="keyword">return</span> rk[x+w]&lt;rk[y+w];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> rk[x]&lt;rk[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sa[i]=i,rk[i]=s[i];</span><br><span class="line"><span class="keyword">for</span>(w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">sort</span>(sa+<span class="number">1</span>,sa+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在上面的这个实现中，最外层 for 循环开始时，$rk$ 的值就是子串长度为 $w$ 的值，而 $sa$ 的值是子串长度为 $w/2$ 的时候的值。每次 for 循环，先根据当前的 $rk$ 来把 $sa$ 更新到当前状态，再根据 $sa$ 计算出下一个 $rk$。</p><p>根据 $rk$ 来给 $sa$ 排序时（也就是 sort 函数），此时的 $sa$ 数组里什么值其实是无关紧要的，只要是任意一个 $n$ 的排列就行（因为关键字和 $sa$ 没关系），我们以 $rk_{sa_i}$ 为第一关键字，$rk_{sa_i+w}$ 为第二关键字。原因是在子串 $s[sa_i,sa_i+2w]$ 中，根据字符串比较的原则，要先比前面的 $s[sa_i,sa_i+w]$ 的部分。</p><p>后面根据 $sa$ 来更新 $rk$ 时，注意当两个子串相等时他们的 $rk$ 也要相等。</p><p>倍增 $O(\log n)$，排序 $O(n\log n)$，总时间复杂度 $O(n\log^2n)$。</p><h3 id="基数排序优化">基数排序优化</h3><p>在给 $sa$ 排序的过程中，我们可以使用基数排序来优化到 $O(n)$ 排序。</p><p>首先我们要了解基数排序，而我们所使用的基数排序又依赖于计数排序，所以我们先讲讲计数排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[a[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)ans[i]=cnt[a[i]]--;</span><br></pre></td></tr></table></figure><p>十分的简洁明了。其中 $a$ 是待排序数组，$m$ 是值域，$ans_i$ 表示 $a_i$ 的排名。值得注意的是，这是一个稳定的排序算法，因为统计答案的时候我们采用了原数组倒序的方式。如果 $m=n$，那么 $ans$ 就是排序之后的答案数组。时间复杂度显然是 $O(n+m)$。</p><p>下面我们介绍一下基数排序。这是一个多关键字的排序，我们现在有 $n$ 个元素，每个元素有 $2$ 个关键字。$a_i$ 表示第 $i$ 个元素的第 $1$ 个关键字，$b_i$ 是第二个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[b[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)tmp[i]=cnt[b[i]]--;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[tmp[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)ans[i]=cnt[tmp[i]]--;</span><br></pre></td></tr></table></figure><p>为什么这样是正确的呢？第一次我们先对第二关键字排序。第二次排序的时候，当第一关键字不同，此时可以被正确排序。而当第一关键字不同的时候，因为计数排序是稳定的排序，所以我们原先保留的第二关键字的顺序不会变，就完成了排序。</p><p>把这项技术运用到我们的倍增法里，我们就得到了一个 $O(n\log n)$ 的求后缀数组的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,rk[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>],id[N*<span class="number">2</span>],cnt[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">128</span>;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[i]]--]=i;</span><br><span class="line"><span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i<span class="number">-1</span>]]==oldrk[sa[i]])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i+w]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)id[cnt[rk[i+w]]--]=i;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[id[i]]]--]=id[i];</span><br><span class="line"><span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了帮助理解，我决定还是讲解一下。</p><p>首先我们计算出了子串长度为 $1$ 时的 $sa$，再据此计算出 $rk$ 的数值版本。在 for 循环中，我们先根据第二关键字计数排序（也就是 $rk_{sa_i+w}$）。排完序后的 $id_i$ 表示 $s[j+w,j+2w-1]$ 在 $j=1,2,3,\cdots,n$ 这 $n$ 个子串中的排名为 $i$ 的 $j$ 的值。然后再根据第一关键字，以 $id$ 倒序的顺序来进行计数排序。这一次计数排序保证了在 $rk_i$ 不同的时候，较小的排在前面。而 $id$ 倒序的顺序保证了在 $rk_i$ 相同的时候，$rk_{i+w}$ 较小的能排在前面。</p><h3 id="常数优化">常数优化</h3><p>我们已经写出了 $O(n\log n)$ 的算法，但这份代码的常数巨大，需要优化常数。</p><p>先优化几个比较显然的点。</p><ol><li>我们每次计数排序的值域不用开到 $n$，由代码可知上一次的 $p$ 就是值域。</li><li>当计算完 $rk$ 后，若 $p=n$，则说明算法完成了。因为此时 $rk$ 两两不同，再往后排也不会有新的结果。</li></ol><p>然后思考一下对第二关键字排序的实质。</p><p>我们发现，对于 $i+w&gt;n$ 的部分，$rk_{i+w}$ 实质上是等于 $0$ 的，因此，这一部分会被放在 $id$ 的最前面。</p><p>在对第二关键字排序的时候，此时的 $sa$ 数组其实是上一次的保留结果，此时 $sa_i$ 表示所有长为 $\frac{w}{2}$ 的子串中，第 $i$ 名的起始位置。我们直接从第 $1$ 名开始，如果 $sa_i&gt;w$，我们直接把 $sa_i-w$ 放进 $id$ 即可。此时我们发现，$sa_i$ 最大是 $n$，所以 $sa_i-w$ 最大是 $n-w$，正好跟前面对上了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> p,m,rk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],id[N*<span class="number">2</span>],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[x]==oldrk[y]&amp;&amp;oldrk[x+w]==oldrk[y+w])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">m=<span class="number">128</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[i]]--]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;;w&lt;&lt;=<span class="number">1</span>,m=p)&#123;</span><br><span class="line"><span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++)id[++cur]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(sa[i]&gt;w)id[++cur]=sa[i]-w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)cnt[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[id[i]]]--]=id[i];</span><br><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)oldrk[i]=rk[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line"><span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==n)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graphviz 图论画图工具笔记</title>
      <link href="/2024/04/12/graphviz/"/>
      <url>/2024/04/12/graphviz/</url>
      
        <content type="html"><![CDATA[<h1>简介</h1><p>如题，是一个可以便捷生成图论中各种图的工具。</p><h1>下载 &amp; 安装</h1><p><a href="https://graphviz.org/download/">链接</a></p><p>自己选适合自己操作系统的版本。</p><p>安装以 Windows 为例，其实也没什么要注意的点，把 “Add Graphviz to the system PATH” 中的任意一个勾上就行了。</p><p>命令行试试 <code>dot -V</code>，如果有输出说明安装成功，没输出检查一下勾没勾上上述选项。</p><h1>配置</h1><p>以 VSCode 为例。</p><p>插件搜索 Graphviz，安装 Graphviz Interactive Preview 和 Graphviz (dot) language support for V。</p><p>前者是用于实时生成预览图，后者提供语法高亮。</p><h1>教程</h1><p>Graphviz 源文件的扩展名是 <code>.dot</code>。所以我们在 VSCode 中新建一个 <code>.dot</code> 文件。你会发现右上角有一个小图标，点开它，就有了预览界面。</p><p>先试着写一点简单的图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    A -&gt; B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>digraph</code> 定义了一个有向图，这个有向图里有 <code>A</code> 和 <code>B</code> 两个结点，其中 <code>A</code> 向 <code>B</code> 连了一条有向边。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    A [color = red, shape = box, style = dashed]</span><br><span class="line">    B [color = blue, shape = ellipse, style = bold]</span><br><span class="line">    A -&gt; B [label = &quot;A to B&quot;, color = red, style = dashed]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来一一解读一下。<br>第一行我们定义了一个有向图，这和上个示例一样。<br>第二行我们定义了一个结点 <code>A</code>，它有一些属性，如：红色，方形，虚线。<br>第三行我们定义了一个结点 <code>B</code>，它有一些属性，如：蓝色，椭圆形，加粗线。<br>第四行我们定义了一个有向边 <code>A -&gt; B</code>，它的附加文本是 <code>A to B</code>，其他同上。</p><p>详细的介绍可以参照<a href="https://www.graphviz.org/doc/info/attrs.html">官方文档</a>。</p><p>根据以上内容，我们可以轻松地写出来一个通过一些字符串来构建可视化 Trie 树的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> e[<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line"><span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!t[p].e[c])t[p].e[c]=++tot;</span><br><span class="line">p=t[p].e[c];</span><br><span class="line">&#125;</span><br><span class="line">t[p].s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].e[i])&#123;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>&lt;&lt;t[p].e[i]&lt;&lt;<span class="string">&quot; [label = \&quot;&quot;</span>&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i)&lt;&lt;<span class="string">&quot;\&quot;]&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(t[p].e[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;out.dot&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="built_in">insert</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;digraph&#123;&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line"><span class="keyword">if</span>(t[i].s)</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; [style = bold]&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于输出的文件，我们可以通过 <code>dot -Tpng 1.dot -o 1.png</code> 来把 <code>.dot</code> 文件转化成 <code>.png</code> 图片。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串·KMP</title>
      <link href="/2024/04/03/algorithm/string/kmp/"/>
      <url>/2024/04/03/algorithm/string/kmp/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><h2 id="约定记号">约定记号</h2><p>$s[l,r]$ 代表从 $l$ 到 $r$ 的子串。</p><h2 id="pi-函数">$\pi$ 函数</h2><p>对于一个字符串 $s$，它的 $\pi$ 函数是它的前缀和后缀相等的最长长度。</p><p>$$ \pi=\max_{s[1,i]=s[n-i+1,n]} i $$</p><p>进一步，我们定义 $\pi_i$ 是字符串前 $i$ 个字符组成的子串的 $\pi$ 函数值。特别的，定义 $\pi_1 =0$。</p><p>下面我们考虑如何求出 $\pi$ 数组。</p><p>对于 $\pi_1=0$ 是确定的，考虑递推。</p><p>假设我们当前求出了 $\pi_1,\pi_2,\cdots,\pi_i$ 要求出 $\pi_{i+1}$。</p><p>有一个特殊情况，如果 $s[\pi_i+1]=s[i+1]$，那么 $pi_{i+1}=\pi_i+1$。</p><p>根据 $\pi$ 函数定义，$s[1,\pi_i]=s[i-\pi_i+1,i]$，那么如果 $s[\pi_i+1]=s[i+1]$，就有了 $s[1,\pi_i+1]=s[i-\pi_i+1,i+1]$，进而有 $\pi_{i+1}=\pi_i+1$。</p><p>下面考虑当 $s[i+1]\ne s[\pi_i+1]$ 时的情况：</p><p>还是一样的，$s[1,\pi_i]=s[i-\pi_i+1,i]$，$\pi_{i+1}$ 肯定不比 $\pi_i$ 大，所以我们要在 $[1,\pi_i]$ 中找到一个最大的 $j$ 使得 $s[i-j+1,i+1]=s[1,j+1]$，此时 $\pi_{i+1}=j+1$。</p><p>注意到此时 $s[1,j]$ 是 $s[1,\pi_i]$ 的前缀，$s[i-j+1,i]$ 是 $s[i-\pi_i+1,i]$ 的后缀，又因为 $s[1,\pi_i]=s[i-\pi_i+1,i]$，所以 $[i-j+1,i]$ 是 $s[1,\pi_i]$ 的后缀。</p><p>当满足 $s[i-j+1,i+1]=s[1,j+1]$ 且 $j$ 最大时，也就是 $s[1,\pi_i]$ 的前缀和后缀相等且长度最长的时候，我们发现此时正好和 $\pi$ 的定义对上了，那么此时的 $j$ 就是 $\pi_{\pi_i}$。</p><p>若此时 $s[j+1]=s[i+1]$，那么 $\pi_{i+1}=j+1$。否则一直这么找下去，直到真的没有相同的前后缀。</p><p>求 $\pi$ 数组代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=pi[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])j++;</span><br><span class="line">    pi[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP-算法">KMP 算法</h2><p>该算法用于解决这样的问题：</p><p>给定文本串 $s$ 和模式串 $t$，求 $s$ 中所有出现的 $t$ 的位置。</p><p>我们可以使用这样的方法来解决：令 $f=s+c+t$，其中 $c$ 是不属于字符集的一个字符，求 $f$ 的 $\pi$ 数组，若 $\pi_i=len_t$，则在以 $i$ 为结尾的位置匹配上了。代码略。</p><p>另外还有一种不用显式建出字符串 $f$ 的方法：我们先跑出 $t$ 的 $\pi$ 数组，然后直接匹配，过程类似于求 $\pi$ 数组，具体见代码，其中 $mth_i$ 表示到 $s_i$ 匹配了多少位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=mth[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;t[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">    <span class="keyword">if</span>(t[j+<span class="number">1</span>]==s[i])j++;</span><br><span class="line">    mth[i]=j;</span><br><span class="line">    <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">        <span class="comment">// 此时匹配上了</span></span><br><span class="line">        j=pi[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>联合省选2024·游记</title>
      <link href="/2024/04/02/article/lhsx2024/"/>
      <url>/2024/04/02/article/lhsx2024/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>关于 CSP 没什么好说的，A 切了，B 35pts 暴力之后跑路。</p><p>C 一看，第一次遇见大模拟，有点害怕，草草写了个 15pts 性质分跑路了，然后一直在做 D 题。</p><p>总之就是很飞舞，D 题暴力挂了，C 挂了 10 pts，最后只有 140 分。</p><p>压线 6 级勾，有点惊喜但不多，可以参加 NOIP。</p><h3 id="NOIP"><a href="#NOIP" class="headerlink" title="NOIP"></a>NOIP</h3><p>A 切了，B 看了之后有点害怕，以为是什么 Tarjan 图论题。</p><p>因为我 Tarjan 学得不好所以打了个部分分草草了事</p><p>我为什么没看见暴力分？我为什么没看见暴力分？我为什么没看见暴力分？</p><p>C 题更害怕，做了个特殊性质。</p><p>我为什么没看见暴力分？我为什么没看见暴力分？我为什么没看见暴力分？</p><p>D 题，是个 DP，感觉很可做诶，写了个 $O(n^2)$ DP，后面不会优化了，跑路。</p><p>最后只有 146 分，大失败，这也是为什么我在这之后的比赛基本不想正解，只打部分分。</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>是一个省选模拟赛。</p><p>上来看 A，什么抽象题面，转去看 B，发现有 59 分是送的，赶紧写了。</p><p>读了 A，暴力思维难度较大，于是看 C，发现有 21 分是送的，赶紧写了。</p><p>后面就是 A 和 C 交替进行，C 写了一个类似于分层图 + 双端队列 BFS 的东西但是复杂度假了。A 分析了一会感觉不会就摆了。</p><p>最后 80 分，大众分，对得起我的水平。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>依然是省选模拟赛，但是是 OI 赛制。</p><p>A 题奇怪数学题，开场 10 min 就有人说切了，有点害怕，后来乱猜了结论之后就过了。</p><p>B 题像 DP，糊了一个 $O(qn^3)$ DP，期望得分 19 分。</p><p>C 题像奇怪 DS 题，感觉很繁琐，而且暴力的 $O(n!)$ 不给过，于是思考特殊性质，但是不会，去看 B。</p><p>B 还是不会，去看 C，此时恍然大悟就开始写，结果最后没时间调了。</p><p>评测，A 没挂分，RP—，B甚至多得了17分，这下 RP 掉光了，C 没得分，最后是获得了我 OI 生涯的第一个 rk1，令人感慨。</p><p>最后发现 BC 都是 DP，吓人。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>此时我已经狂暴 whk 一周了，感觉很颓。又因为作业比较多，几乎没早睡过，比较困。晚上去试机有点晕车。</p><p>到达山师二附中，面到了 <a href="https://www.luogu.com.cn/user/679581">MrPython</a> 老师。很可爱，是 Linux 爷，但是他走错考场，于是就有了我们戏剧性相见的一幕。</p><p>面基完赶紧去考场，坐下之后不知道敲什么，看左边在敲一个不知道是什么的树上算法，右边在敲 Dinic，我就敲了一个树剖，结果发现挂了一个点，不想调了就没调。<br>发现老头、吴爷、豆、王老师都在一个考场，于是就去聊天。豆在测试快读快写和 cin cout 的速度差异，运用了控制变量法。</p><p>发现吴老师和 nrd 一个考场，想去看，但是太远了没去，只能羡慕 Linux 爷了。</p><p>回家看了看树剖为什么挂了，发现是取模问题，看了一个关于 pbds 的博客，转念一想不会出板子题，就没背。</p><p>明天准备罚坐，放张图片镇楼。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nhc1vva8.png" alt=""></p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上到了考场门口，先和各路大神交流一下，进考场之后基本在发呆。</p><p>公布密码之后先看题，A 抽象，B 抽象，C 更抽象。按照以往惯例我先开了 A。</p><p>推了下式子，发现 $\sum x_{i\bmod n}$ 可以 $O(1)$ 求，然后又发现最终答案和每个 $x’_i$ 的具体取值无关，于是想到了二分答案。</p><p>二分写完之后调样例，第二个死活调不过去，于是在大概十点半的时候放弃了，去看 B，发现 B 有 12 分是送的，赶紧写了，调了一会过了样例。</p><p>看 C，感觉题面极其抽象，而且要满足的限定条件很多，感觉写暴力有点不划算，回去调 A。</p><p>偶然的一个机会我输出了一个中间变量，发现我错的点都有一个明显的共同特征：二分域上只有一个点满足要求。进一步结合数据分析，发现此时 $x$ 正好是 $x_0$ 的倍数，于是开心写了个特判然后过了第二个样例。</p><p>第三个样例，麻烦，又有很多不对的地方。于是我拓展特判到了 $n&gt;1$ 的情况，此时码长来到了 3.5k，发现死活过不去。</p><p>调了半个小时，果断放弃了 A，去看 B 特殊性质。感觉像 01trie，但是我仅限于听过这个东西，用贪心打了个 B 性质，发现错的离谱，于是就放弃了。再去看 C 还是那么的抽象，于是又回去看 A 了。</p><p>开始一个个排查着样例里出错的测试点，前几个还好，是因为特判的边界情况，但是我突然发现了一个样例有点不对，定睛一看：</p><p>卧槽，原来是没有单调性的。</p><p>崩溃了。</p><p>保护了一下一些特殊性质分之后就摆了，C 决定输出 0，此时还剩 20 min。</p><p>还没出考场就去问别人 A 怎么做的，发现吴爷也是二分，王老师写的分讨但是没过，老头分讨把 A 切了。</p><p>下楼，听刘老师说就是分讨，而且蒋老师分讨接近切 A，拜谢/bx/se。</p><p>讨论了一路关于二分单调性的东西，最终豆得出结论：$k$ 较大时有单调性，较小时没有，我恍然大悟。</p><p>回家吃了饭，下午还得去学校团建，累。</p><p>回家估分。A 比我预期低十分，但是该得的分挂了，不该得的分得了。B 暴力拿到了。</p><p>一问，一车写了 BC 更多部分分的，我是 shaber。</p><p>十点被逼迫睡觉了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>希望别漏下性质分。</p><p>八点多到的考场，打了缺省源就开始睡觉。</p><p>公布密码。一看，A 疑似太疑似了，看到 $\sum n \leq 80$，暴力分都不给了？去看 BC 结果发现更抽象，于是回来写 A 的 A 性质，写了一会发现过了。</p><p>去看了 B，草草把 B 的前 5pts 写了，输出 1 然后跑路去 C。C 这题面就不想看，跑路回 A，发现 A 的纯暴力能过，就写了 A 暴力。</p><p>然后看 B 性质。先想了一个非常贪的东西，写出来发现不行，然后就对着样例调。优先队列改成枚举，枚举改成优先队列，贪心思路来来回回改了不下十遍，样例三总是有几个数不对，但是样例四过了，样例五过不了。</p><p>A 一直写到了 12:50。出考场问一下，只有蒋老师把 A 前四个样例切了，用的是树剖套树套树，害怕，然后发现 B 都写了 20pts，崩溃了。</p><p>回家后发现 A 是 DP，以后贪不对的时候记得想想 DP。</p><p>笑，估分，A 比保底得分多了 10pts，没白贪。</p><h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day inf"></a>Day inf</h1><p>出分。$40 + 12 + 0 + 50 + 10 = 112$。</p><p>感觉挺唐诗的，D1T1<br>与我预期挂了 20pts，D2T1 挂了 -10pts。</p><p>排名 70 多，不忍心看。</p><p>崩溃。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/2024/04/02/Introduction/"/>
      <url>/2024/04/02/Introduction/</url>
      
        <content type="html"><![CDATA[<h1>这是一个自我介绍</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2024/04/02/Test/"/>
      <url>/2024/04/02/Test/</url>
      
        <content type="html"><![CDATA[<h1>This is a testing article.</h1><p>$$ 若a,b&gt;0，则 a+b \ge 2\sqrt{ab} $$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚树</title>
      <link href="/2023/05/10/algorithm/graph/virtual-tree/"/>
      <url>/2023/05/10/algorithm/graph/virtual-tree/</url>
      
        <content type="html"><![CDATA[<h1>引入</h1><p>给你 $n$ 个点的一棵树，每条边有边权。从中选取一些关键结点，你需要切断一些边，使得没有任何关键节点与 $1$ 号点联通，最小化切断边的总边权。</p><p>$O(n)$ 做法是显然的。考虑树形 DP。我们设 $f_u$ 为以 $u$ 为根的子树内（不包括 $u$）切断一些边使得没有任何关键结点与 $u$ 联通的边权和最小值。容易得到转移方程。</p><p>设 $v$ 是 $u$ 的一个儿子，$w$ 为 $u$ 到 $v$ 的边权。</p>若 $v$ 是关键结点，$f_u=f_u+w$，否则 $f_u=f_u+\min\{f_v,w\}$。<p>现在把问题升级一下。$q$ 组询问，每次给定一些关键结点，求答案。所有询问中关键结点个数的和与 $n$ 同阶。</p><p>我们把上面的算法跑 $q$ 次，就得到了一个 $O(nq)$ 的算法，这是远远不够的。</p><p>但是所有询问中关键结点个数的和与 $n$ 同阶，在关键点数量比较少的时候，总会有一些其他结点是无用的。我们有没有一种方法把这棵树的信息浓缩呢？答案是有的。</p><h1>虚树</h1><p>不要被名字吓到。所谓虚树，不过是一个重构树，在这个重构树上进行 DP 和在原树上 DP 是等价的。这个重构树上当然结点数量越少越好。</p><p>那么这个重构树上最少需要有哪些结点呢？先抛出结论：任意两个关键结点的 LCA 都是必须的。</p><p>为什么呢？我们在树上 DP 的过程其实是把一个个子树的信息合并。为了不错过任何子树合并的结点，自然是任意两个关键结点的 LCA。</p><p>当然，我们 $O(n^2\log n)$ 枚举任意两个关键结点的 LCA 肯定是不行的。所以我们需要一个快速构建虚树的算法。</p><h1>构建虚树</h1><p>我们先把原树的 dfn 求出来。考虑维护一个结点 dfn 值单调递增的单调栈。单调栈中每一个结点都是虚树上的点。</p><p>初始时，单调栈中有根节点 $1$，dfn 为 $1$。我们把关键结点按照 dfn 升序排序，依次考虑把每一个结点加入到虚树中。</p><p>假设当前考虑点 $u$，栈顶结点为 $t$，栈顶下面的一个结点是 $r$，我们求出 $p=\operatorname{LCA}(u,t)$。则一定有 $dfn_u&gt;dfn_p$。</p><ol><li><p>若 $t=p$，则我们直接把 $u$ 加入到栈中（也就是虚树中）。</p></li><li><p>否则，我们做如下处理：</p><ul><li><p>若 $dfn_r&gt;dfn_p$，则弹出栈顶直到 $dfn_r\leq dfn_p$。</p></li><li><p>此时，若 $r=p$，直接把 $t$ 弹掉然后加入 $u$ 即可。</p></li><li><p>否则，把 $t$ 弹出后，把 $p$ 和 $u$ 加入栈即可。</p></li></ul></li></ol><p>算法结束后，加入过栈的结点就是虚树中的结点。</p><p>下面我们来讨论这个算法的正确性。</p><p>当 $t=p$ 时，因为 dfn 递增，所以 $p$ 到 $u$ 的路径上没有其他关键结点，直接加入 $u$ 是正确的。</p><p>否则，我们要讨论两种情况：$p$ 加入过栈中，$p$ 没加入过栈中。</p><p>弹栈的过程，是为了寻找栈中相邻的两个点 $t$ 和 $r$，这两个点把 $p$ 夹在中间。</p><p>如果 $r=p$，也就是说 $p$ 加入过栈中，把 $r$ 弹掉后就变成了 $t=p$ 的情况。</p><p>如果，$r\neq p$，说明 $p$ 没加入过栈中，则我们需要把 $p$ 加入到栈中，也就是加入到 $r$ 和 $t$ 之间，然后把 $r$ 删除，就变成了 $t=p$ 的情况。</p><p>综上所述，这个算法是正确的。</p><p>分析时间复杂度。遍历每个点 $O(n)$，求 LCA 要 $O(\log n)$，单调栈均摊 $O(1)$，所以这个算法的时间复杂度是 $O(n\log n)$。</p><p>分析结点个数。通过算法，我们可以直观地发现，每两个 dfn 相邻的关键点最多可能会让一个 LCA 加入到虚树中，所以结点个数是 $O(n)$ 的。</p><p>我们在弹栈的时候，把次栈顶向栈顶连边即可得到虚树的图。</p><h1>解决问题</h1><p>回到原来的问题。我们建立好虚树，虚树中每条边的边权是原来树上两个点之间所有边的边权最小值，这是显然的，因为如果想要断边，只需要断最小的那条边就行。这可以轻松地用倍增维护。</p><p>每次询问在虚树上跑 DP，就 $O(n)$ 解决了这个问题。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
