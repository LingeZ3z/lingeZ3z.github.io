<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>容斥原理</title>
      <link href="/2024/08/13/algorithm/math/inclusion-exclusion-principle/"/>
      <url>/2024/08/13/algorithm/math/inclusion-exclusion-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>相信各位小学都学过容斥原理的三元版本，这里就不多赘述了。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>我们关注容斥原理的本质，其实就是求多个集合的并的大小。</p><p>令 $U$ 为全集，所有的 $S_i\subset U$。</p><p>下面把它拓展到 $n$ 元：</p><script type="math/tex; mode=display">|\bigcup_{i=1}^n S_i|=\sum_{m=1}^n(-1)^{m-1}\sum_{|a|=m,a_i<a_{i+1}}|\bigcap_{i=1}^m S_{a_i}|</script><p>如果我们想求集合的交的大小，我们同样可以使用容斥原理，只需要套用下面的式子转化一下：</p><script type="math/tex; mode=display">|\bigcap_{i=1}^n S_i|=|U|-|\bigcup_{i=1}^n \overline{S_i}|</script><p>重点是将其拓展到更一般的方面：</p><ul><li>令 $U$ 为全集。</li><li>有 $n$ 个性质 $P_i$ 和 $n$ 个集合 $S_i$。</li><li>$\forall x\in U$，$x$ 具有 $P_i$ 性质 $\Leftrightarrow x\in S_i$。</li></ul><p>则有：</p><script type="math/tex; mode=display">|\bigcap_{i=1}^n S_i|=|U|-\sum_{k=1}^n(-1)^{k-1}\sum_{|a|=k,a_i<a_{i+1}}|\bigcap_{i=1}^k \overline{S_{a_i}}|</script><p>考察其意义。$\bigcap_{i=1}^n S_i$ 表示的是<strong>同时满足所有性质的元素数量</strong>，$\bigcap_{i=1}^k \overline{S_{a_i}}$ 表示的是 <strong>同时不满足性质 $P_{a_i}$ 的元素数量</strong>。</p><p>注意到非常好的一点是，等式的两边都是集合的交。</p><p>下面看几个应用。</p><h1 id="不定方程解数量"><a href="#不定方程解数量" class="headerlink" title="不定方程解数量"></a>不定方程解数量</h1><p>有 $n$ 个变量 $x_i$，每个变量有限制形如 $0\leq x_i\leq b_i$，求 $\sum_{i=1}^n x_i=m$ 的解数量，$n$ 较小。</p><p>构造容斥模型。</p><ul><li>我们把一组解 $(x_1,x_2,x_3,\cdots,x_n)$ 看做 $U$ 中的元素。</li><li>考虑先去掉 $x_i\leq b_i$ 的限制，令 $U$ 等于所有满足 $\sum_{i=1}^n x_i=m$ 的解的集合。</li><li>令性质 $P_i$ 为 $x_i\leq b_i$。</li></ul><p>现在有了模型，直接套上容斥式子：</p><script type="math/tex; mode=display">|\bigcap_{i=1}^n S_i|=|U|-\sum_{k=1}^n(-1)^{k-1}\sum_{|a|=k,a_i<a_{i+1}}|\bigcap_{i=1}^k \overline{S_{a_i}}|</script><p>其中 $|U|$ 使用插板法可求得 $|U|=\binom{n+m-1}{n-1}$，现在考虑怎么求 $\sum_{|a|=k,a_i&lt;a_{i+1}}|\bigcap_{i=1}^k \overline{S_{a_i}}|$。</p><p>考虑其实际意义：$\overline{S_{i}}$ 中的 $x$ 不满足 $x_{i}\leq b_{i}$，也就是 $x_i\geq b_i+1$。若让所有 $\overline{S_{i}}$ 并起来，就是说 $x_{a_i}\geq b_{a_i}$，其余的满足 $x_i\geq 0$。这就变成了有下界不定方程解数量，我们是会的，答案是 $\binom{m-\sum(b_{a_i}+1)+n-1}{n-1}$。</p><p>所以，综合起一个式子，答案就是：</p><script type="math/tex; mode=display">\binom{n+m-1}{n-1}-\sum_{k=1}^n(-1)^{k-1}\sum_{|a|=k,a_i<a_{i+1}}\binom{m-\sum(b_{a_i}+1)+n-1}{n-1}</script><p>朴素做，时间复杂度 $O(n2^n)$。</p><h1 id="HAOI2008-硬币购物"><a href="#HAOI2008-硬币购物" class="headerlink" title="[HAOI2008] 硬币购物"></a>[HAOI2008] 硬币购物</h1><p>一共有四种货币，面值是 $c_i$。$t$ 组询问，每次询问给你每种货币的数量和一个数 $s$，问用这些货币付 $s$ 块钱有多少种方案。</p><p>跟上面那个挺像的，是不是。直接构造容斥模型：</p><ul><li>我们把一组解 $(x_1,x_2,x_3,x_4)$ 看做全集 $U$ 中的元素。</li><li>考虑先去掉上界的限制，令全集 $U$ 为所有满足 $\sum_{i=1}^4c_ix_i=s$ 的 $(x_1,x_2,x_3,x_4)$。</li><li>令性质 $P_i$ 为 $x_i\leq d_i$。</li></ul><p>还是先考虑全集 $U$ 是什么，是不是直接就是一个完全背包？</p><p>然后考虑怎么求后边那些，是不是就是某些货币有下界，有的没有？我们先把有下界那些强制选上，剩下的是不是又是一个完全背包？</p><p>令 $f_i$ 为四种货币无限量，付 $i$ 块钱的方案数，则答案就是：</p><script type="math/tex; mode=display">f_s-\sum_{k=1}^4 (-1)^{k-1} \sum_{|a|=k,a_i<a_{i+1}}f_{s-\sum_{i=1}^k c_{a_i}d_{a_i}}</script><p>直接做这个式子就好了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gym105214E Enumerating Substrings 题解</title>
      <link href="/2024/08/02/problem/Gym105214E/"/>
      <url>/2024/08/02/problem/Gym105214E/</url>
      
        <content type="html"><![CDATA[<h1 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h1><p>神秘性质数数题。</p><h1 id="Descr"><a href="#Descr" class="headerlink" title="Descr"></a>Descr</h1><p>对于一个字符串，若其每个字符出现不超过 $2$ 次，则称其是 $\operatorname{beautiful}$ 的。</p><p>共有 $k$ 种字符，字符串 $S$ 长为 $n$，$T$ 长为 $m$，定义 $f(S,T)$ 为 $T$ 在 $S$ 中不重叠出现的次数。求：</p><script type="math/tex; mode=display">\sum_S \sum_{T \operatorname{is}\operatorname{beautiful}}f(S,T)</script><h1 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h1><p>看到字符串 $T$ 这么奇怪，肯定先从 $T$ 入手。尝试发掘一下 $T$ 的性质。</p><p>注意到 $f(S,T)$ 和字符串匹配的规则有些相似，不妨从 $T$ 的 的 $\operatorname{border}$ 发掘一下。</p><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>若 $T$ 有 $\operatorname{border}$，则其有且仅有这一个 $\operatorname{border}$。</p><p>简要说明一下，若其有两个或以上的 $\operatorname{border}$，容易发现其第一个字符出现超过 $2$ 次。</p><p>所以我们可以把一个 $T$ 唯一地表示为 $wxw$ 的形式，其中 $w,x$ 为字符串。</p><h2 id="Corollary"><a href="#Corollary" class="headerlink" title="Corollary"></a>Corollary</h2><p>若 $T$ 有 $\operatorname{border}$，则其内部的 $x$ 无论取什么字符串，都不能形成新的 $\operatorname{border}$。</p><p>若形成，则有两个 $\operatorname{border}$，与上面的 Observation 矛盾。</p><p>很好！我们现在发现了两条非常有用的性质！！1</p><p>然而，怎么用是个关键。</p><p>先确定一下思路，我们对于每个固定的 $w$ 的长度，计算出有多少种 $T$ 是 $\operatorname{beautiful}$ 的，然后让其跟所有的 $S$ 匹配。</p><p>现在让我们考虑这个问题的简单版（这往往十分有效）：假如 $T$ 没有 $\operatorname{border}$，那么怎么求出 $\sum_S f(S,T)$？</p><h2 id="Claim"><a href="#Claim" class="headerlink" title="Claim"></a>Claim</h2><p>若 $T$ 没有 $\operatorname{border}$，则有：</p><script type="math/tex; mode=display">\sum_S f(S,T)=k^{n-m}(n-m+1)</script><p>乍一看没什么问题，$T$ 在 $S$ 中出现的位置有 $n-m+1$ 种，剩下的位置随便填有 $k^{n-m}$ 种方案，乘起来就对了。</p><p>仔细一看，其实也没什么问题。当 $T$ 在 $S$ 中多次出现的时候也能够被正确计算，原因是：若 $T$ 在 $S$ 中出现多次，则其在每一次出现的时候都会被算上一次贡献。</p><p>现在，若 $T$ 有 $\operatorname{border}$ 该怎么办呢？</p><p>我们使用容斥原理。$T=wxw$，则当 $wxwxw$ 出现的时候 $T$ 会被算两次，实则应该算一次，所以减去 $wxwxw$ 出现时的答案。然后我们发现当 $wxwxwxw$ 出现时会被减两次，所以我们再加回来……</p><p>一直这么做下去，直到长度超过了 $m$ 停止，就是对的。</p><p>现在来到了相对最难的部分：如何对于每个固定的 $w$ 的长度，计算出有多少种 $T$ 是 $\operatorname{beautiful}$ 的。</p><p>既然 $w$ 固定后 $x$ 无论怎么填都不会有新的 $\operatorname{border}$，那么不妨转变为算 $x$ 的方案数。</p><p>具体地，设 $f_{i,j}$ 为长度为 $i$，字符种数为 $j$ 的 $x$ 有多少种，不难发现 $x$ 也是 $\operatorname{beautiful}$ 的。</p><p>先别急着想转移，我需要先明确一下，我们在 DP 的时候不考虑里面的字符具体填的是什么，我们只关心这个长为 $i$ 的字符串哪个位置和哪个位置的字符相同。所以我们有：</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j-1}+(i-1)f_{i-2,j-1}</script><p>为什么呢？</p><p>首先 $f_{i,j}=f_{i-1,j-1}$ 是显然的，因为我们直接把新增的那一种字符放到最后即可。</p><p>那怎么解释 $(i-1)f_{i-2,j-1}$ 呢？？不难发现这种情况其实是当前字符出现了两次，我们把这两次的其中一次放到末尾，另外一次在前面 $i-2$ 个字符旁的 $i-1$ 个间隙选一个插入即可。</p><p>聪明的小伙伴可能就会发现了：为什么必须要把其中一个放在最后呢？？？</p><p>其实这很好解释，如果没放在最后，那最后的一定是只出现一次的字符，那就已经包含在第一种情况了。</p><p>最后我们考虑给 $x$ 填上字符，让它变成有血有肉的 $\operatorname{beautiful}$ 的字符串！只要给 $f_{i,j}$ 乘上 $P_k^j$ 就可以了！</p><p>那么对于长为 $m$ 的 $T$ 呢？我们固定了 $w$ 的长度，然后枚举 $x$ 的字符种类数 $c$，我们直接把前面一半 $w$ 放到 $x$ 里面一块填充字符，其方案数就是 $\sum_c P_k^{c+w} f_{m-2w,c}$。</p><p>还有一个地方没处理，我们怎么计算没有 $\operatorname{border}$ 的 $T$ 的方案数？直接拿所有的 $T$ 方案数减去所有有 $\operatorname{border}$ 的即可。</p><p>最后只要预处理 $k$ 的次幂和 $P_k^i$ （其中 $i\leq 2m$）就行了！比那些式子又臭又长的好到不知道哪里去了！！1</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>代码有注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">4e3</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>,mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> f[M][M];</span><br><span class="line"><span class="type">int</span> Pk[M],pk[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Straightforward DP 预处理 f</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,k);j++)&#123;</span><br><span class="line">f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">2</span>)f[i][j]=(f[i][j]+f[i<span class="number">-2</span>][j<span class="number">-1</span>]*(i<span class="number">-1</span>)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理k选i进行排列的方案数，要预处理到 2M</span></span><br><span class="line">Pk[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i++)Pk[i]=Pk[i<span class="number">-1</span>]*(k-i+<span class="number">1</span>)%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理k的次幂（注意要处理到 N）</span></span><br><span class="line">pk[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)pk[i]=pk[i<span class="number">-1</span>]*k%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算所有的T方案数</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">1</span>;c&lt;=m;c++)sum=(sum+f[m][c]*Pk[c]%mod)%mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w*<span class="number">2</span>&lt;=m;w++)&#123;<span class="comment">//枚举w长度</span></span><br><span class="line"><span class="type">int</span> x=m-w*<span class="number">2</span>,tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举字符数c，计算方案数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;=x&amp;&amp;w+c&lt;=k;c++)tmp=(tmp+f[x][c]*Pk[c+w])%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从总数里减去有border的方案数</span></span><br><span class="line">sum=((sum-tmp)%mod+mod)%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行一个容的斥，计算贡献</span></span><br><span class="line"><span class="type">int</span> co=<span class="number">1</span>,len=m;</span><br><span class="line"><span class="keyword">while</span>(len&lt;=n)&#123;</span><br><span class="line">ans=((ans+co*pk[n-len]*tmp%mod*(n-len+<span class="number">1</span>)%mod)%mod+mod)%mod;</span><br><span class="line">co*=<span class="number">-1</span>;</span><br><span class="line">len+=x+w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算没有border的T的贡献</span></span><br><span class="line">ans=(ans+sum*pk[n-m]%mod*(n-m+<span class="number">1</span>)%mod)%mod;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BAEKJOON-19523 题解</title>
      <link href="/2024/07/25/problem/BAEKJOON-19523/"/>
      <url>/2024/07/25/problem/BAEKJOON-19523/</url>
      
        <content type="html"><![CDATA[<p>选自 SDSC2024 Day1 数论选讲。</p><h1 id="Descr"><a href="#Descr" class="headerlink" title="Descr"></a>Descr</h1><p>给定一个 $h\times w$ 的网格图，从左上角的点 $(0,0)$ 开始，你可以在每个格子选择往下或往右走，走出边界会循环，问哈密顿路径条数。</p><p>$h,w \leq 10^6$。</p><h1 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h1><p>本题解分步讲解。因为较为抽象，建议读题解同时自己画图理解。</p><h2 id="Observation-1"><a href="#Observation-1" class="headerlink" title="Observation #1"></a>Observation #1</h2><p>考虑“哈密顿路径”这一条件。</p><p>所谓哈密顿路径，就是不重不漏走每个点<strong>恰好一次</strong>的路径。</p><p>假设有一个点 $(x,y)$ 选择了往下走到 $(x+1,y)$，那么因为每个点只能走一次，所以 $(x+1,y-1)$ 就不能选择往右走到 $(x+1,y)$，只能选择往下走。</p><p>假设这个点 $(x,y)$ 选择了往右走，那么 $(x+1,y)$ 这个点只能从 $(x+1,y-1)$ 走过来，即从 $(x+1,y-1)$ 向右走，否则没有点能走到这里。</p><p>归纳下去，所有的左下-右上的对角线的方向的选择都相同。</p><p>再考虑“循环”这一条件。</p><p>假设有一个位于底部的点 $(h-1,y)$ 其选择了往下走到 $(0,y)$，那么 $(0,y-1)$ 就不能向右走，否则会重复走到一个点，所以要选择向下走。</p><p>假设其选择了向右走，那么因为 $(0,y)$ 位于顶端只能从 $(0,y-1)$ 走过来，那么 $(0,y-1)$ 也必须选择向右走。</p><p>剩余的位于顶部、左侧、右侧的情况也有类似规律。</p><p>上面所有规律的逆命题也成立。</p><p>对这个规律总结归纳，不难发现：</p><p>对于一个点 $(x,y)$，对于所有的 $k$，$((x+k)\bmod h,(y-k)\bmod w)$ 与 $(x,y)$ 选择的方向相同。</p><h2 id="Observation-2"><a href="#Observation-2" class="headerlink" title="Observation #2"></a>Observation #2</h2><p>在上面的结论下，考虑有多少个本质不同的对角线。</p><p>假设有一个人，从一个点 $(x,y)$ 沿着对角线，走遍所有的 $k=0,1,2,\cdots$，容易发现他一定会回到 $(x,y)$。由上文的结论得，能使 $(x,y)$ 回到 $(x,y)$ 的 $k$ 一定满足：</p><p>$x+k\equiv x(\bmod h),y-k\equiv y(\bmod w)$。</p><p>进而可得 $h|k$ 且 $w|k$。</p><p>这样的最小的 $k$ 是 $\operatorname{lcm}(h,w)$。即每条对角线长度都为 $\operatorname{lcm}(h,w)$。</p><p>考虑一共有 $hw$ 个点，每条对角线有 $\operatorname{lcm}(h,w)$ 个点，那么一共有 $\frac{hw}{\operatorname{lcm}(h,w)}=\gcd(h,w)$ 条对角线。</p><p>令 $g=\gcd(h,w)$，也就是说我们只要确定这 $g$ 条对角线的方向就能确定整个方格图的方向。</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>正难则反，一共有 $2^g$ 种选择方向的方案，减去不是哈密顿路径的方案即为答案。</p><h2 id="Observation-3"><a href="#Observation-3" class="headerlink" title="Observation #3"></a>Observation #3</h2><p>考虑一个不合法的方案是什么样的。</p><p>因为点数有限，每个点只有一个方向可走任意一个路径的选择，且不管怎么走都走不出这个图。所以从任意一个点出发，必定构成一个环回到这个点。</p><p>这个环长度显然最大是 $hw$，若取到 $hw$ 说明正好构成哈密顿路径，小于 $hw$ 则说明不合法。</p><p>所以问题转化为统计有多少个路径选择存在一个长度小于 $hw$ 的环。</p><h2 id="Observation-4"><a href="#Observation-4" class="headerlink" title="Observation #4"></a>Observation #4</h2><p>从一个点向下或向右不重复地走，经过的 $g$ 个点，一定恰好在 $g$ 个不相同的对角线上。</p><p><del>画几个图感性理解一下。</del></p><p>略证：</p><p>假设从第一个点 $(x,y)$ 开始走 $k$ 步（$k\leq g$）到达了 $(x’,y’)$，且第一次出现 $(x’,y’)$ 与 $(x,y)$ 在同一对角线的情况，则有：</p><p>$x+d_x+k’\equiv x’(\bmod h),y+d_y-k’\equiv x’(\bmod w)$ </p><p>其中 $d_x+d_y=k$。</p><p>因为是第一次出现，容易知道 $d_x+k’=d_y-k’=\operatorname{lcm}(h,w)=\frac{hw}{g}$，两式相加进而有 $d_x+d_y=\frac{2hw}{g}=k\leq g$。</p><p>得 $2hw\leq g^2$，显然不成立，得证。</p><h2 id="最终章"><a href="#最终章" class="headerlink" title="最终章"></a>最终章</h2><p>上面的结论启示我们不要去关心这 $g$ 个对角线具体是怎么走的，转而去考虑这些总共产生的影响。</p><p>不妨假设在这 $g$ 条对角线中有 $k$ 条往右走，剩下 $g-k$ 条往下走，则每走 $x$ 轮最终产生的移动影响是 $(x(g-k),xk)$。</p><p>因为总是要回到原点，所以有 $h|x(g-k)$ 和 $w|xk$。</p><p>根据上面的 Observation #4，我们知道从一个点走到这个点一定经历了整数轮对角线。如果 $x&lt;\frac{hw}{g}$，那么说明存在长度小于 $hw$ 的环。</p><p>现在考虑枚举 $k$，计算哪些 $k$ 不符合哈密顿路径。</p><p>不难发现只要找到最小的 $x$ 满足 $h|x(g-k)$ 且 $w|xk$ 再判断这个 $x$ 是否小于 $\frac{hw}{g}$ 即可。</p><p>若 $w|xk$，两边同除 $\gcd(w,k)$ 则有 $\frac{w}{\gcd(w,k)}|x\frac{k}{\gcd(w,k)}$。此时 $\frac{w}{\gcd(w,k)}$ 与 $\frac{k}{\gcd(w,k)}$ 互质，则有 $\frac{w}{\gcd(w,k)}|x$，同理有 $\frac{h}{\gcd(h,g-k)}|x$。</p><p>所以最小的 $x=\operatorname{lcm}(\frac{w}{\gcd(w,k)},\frac{h}{\gcd(h,g-k)})$。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01-Trie</title>
      <link href="/2024/07/15/algorithm/ds/01-trie/"/>
      <url>/2024/07/15/algorithm/ds/01-trie/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>众所周知，Trie 是维护一堆字符串的数据结构，那么如果我们把数看做二进制字符串，用 Trie 维护，会得到什么呢？</p><p>答案是 01-Trie。</p><p>01-Trie 利用贪心思想，能够方便地维护异或最大、最小、第 $k$ 大以及相关信息。</p><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>在大多数 01-Trie 中，我们按照数的二进制位从高到低建立。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>同普通 Trie。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> e[<span class="number">2</span>];</span><br><span class="line">&#125;t[N*T];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=T;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[p].e[c])t[p].e[c]=++tot;</span><br><span class="line">        p=t[p].e[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或最大"><a href="#异或最大" class="headerlink" title="异或最大"></a>异或最大</h2><p>下面实现一种最常用的操作：查询在这些数中异或值 $x$ 最大的异或值。</p><p>我们知道异或时，当两位不相同时为 $1$，否则为 $0$。</p><p>现在就有了一个基本思路：尽量在 Trie 上沿着数的相反位走。</p><p>那么为什么这是对的呢？考虑如果从小到大第 $k$ 为本来能往反方向走，却走了相同的方向，那么后面 $k-1$ 位就算全部往反方向走，也最多只有 $\sum_{i=1}^{k-1}2^i=2^k-1$ 的贡献，但是如果我们在第 $k$ 位往反方向走，那么就有 $2^k$ 的贡献，显然比前者大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=T;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[p].e[c^<span class="number">1</span>])p=t[p].e[c^<span class="number">1</span>],ans+=(<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">        <span class="keyword">else</span> p=t[p].e[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或第-k-大"><a href="#异或第-k-大" class="headerlink" title="异或第 $k$ 大"></a>异或第 $k$ 大</h2><p><del>好的现在你已经完全理解了。</del></p><p>给定值 $x$，求其异或 Trie 里的数出来的第 $k$ 大结果。</p><p>为了实现这一操作，我们对插入操作稍作修改，记录子树里有多少个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> e[<span class="number">2</span>],v;</span><br><span class="line">&#125;t[N*T];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=T;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[p].e[c])t[p].e[c]=++tot;</span><br><span class="line">        p=t[p].e[c];</span><br><span class="line">        t[p].v++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们到了一个节点 $p$，且当前 $x$ 的下一二进制位是 $b$，现在我们要选择 $p$ 往哪个方向走。</p><p>如果 $p$ 往下只有一个儿子，那么只能走这一个儿子，无可置疑。</p><p>看看 $p$ 与 $b$ 相反的儿子里有多少个数，如果这个数量小于 $k$，那么答案一定不在这个节点里面，直接往 $b$ 走。</p><p>否则，让 $k$ 减去这个数量，往 $b$ 相反的儿子走。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=T;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!t[p].e[c^<span class="number">1</span>]||t[t[p].e[c^<span class="number">1</span>]].v&lt;k)k-=t[t[p].e[c^<span class="number">1</span>]].v,p=t[p].e[c];</span><br><span class="line"><span class="keyword">else</span> p=t[p].e[c^<span class="number">1</span>],ans+=(<span class="number">1ll</span>&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>某科学的超电磁炮 Round Solution</title>
      <link href="/2024/07/15/contest/%E6%9F%90%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B6%85%E7%94%B5%E7%A3%81%E7%82%AE%20Round%20Solution/"/>
      <url>/2024/07/15/contest/%E6%9F%90%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B6%85%E7%94%B5%E7%A3%81%E7%82%AE%20Round%20Solution/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/top.jpg" alt="Top"></p><p>这是我 OI 生涯中举办的第一场比赛！！1</p><p>全部文件下载链接：<a href="https://github.com/LingeZ3z/MyOIDocs/blob/main/%E6%9F%90%E7%A7%91%E5%AD%A6%E7%9A%84%E8%B6%85%E7%94%B5%E7%A3%81%E7%82%AE%20Round%20Achieved.zip">link</a>。</p><h1>Sol</h1><h2 id="Accelerator">Accelerator</h2><h3 id="暴力1">暴力1</h3><p>直接枚举即可。</p><h3 id="正解">正解</h3><p>暴力统计 $b\geq 3$ 时的结果，拿 <code>std::map</code> 去重的同时统计这些数里有多少个完全平方数。</p><p>考虑到所有的 $a^b\leq n$ 且 $b=2$ 时共有 $\lfloor \sqrt{n} \rfloor$ 种 $a^b$，所以拿上面的结果加上 $\lfloor \sqrt{n} \rfloor$ 再减去统计有多少个完全平方数即可做到不重不漏统计答案。</p><p>实现的时候注意不要使用 <code>sqrt</code>，会爆精度，应该使用 <code>sqrtl</code>。</p><p>考点解析：<code>sqrtl</code>、枚举、人类智慧。</p><h2 id="Kuriko">Kuriko</h2><h3 id="暴力1-2">暴力1</h3><p>暴力连边跑暴力 Dijkstra。</p><h3 id="暴力2">暴力2</h3><p>暴力连边跑 01-BFS。</p><h3 id="暴力3">暴力3</h3><p>建模跑暴力 Dijkstra。</p><h3 id="正解-2">正解</h3><p>建模跑 01-BFS。</p><p>具体地，每个 $u$，从 $u$ 向 $a_u$ 连边，边权为 $0$。</p><p>每个 $a_u$ 枚举其为 $0$ 的二进制位 $x$，向 $a_u \operatorname{or} x$ 连边，边权为 $0$。</p><p>建图时间复杂度 $O(a_u\log a_u)$。</p><p>查询时间复杂度 $O(q(n+M))$。</p><p>考点解析：BFS、图论建模。</p><h2 id="Kamijo">Kamijo</h2><h3 id="暴力1-3">暴力1</h3><p>暴力。</p><h3 id="正解-3">正解</h3><p>单点修改 + 查询直接上线段树。</p><p>每个节点维护这段区间里有几个 <code>a</code> 几个 <code>b</code> 几个 <code>c</code>，需要改几个字符能实现没有子序列 <code>ab</code> <code>bc</code> <code>abc</code>，转移有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">t[p].a=t[p*<span class="number">2</span>].a+t[p*<span class="number">2</span>+<span class="number">1</span>].a;</span><br><span class="line">t[p].b=t[p*<span class="number">2</span>].b+t[p*<span class="number">2</span>+<span class="number">1</span>].b;</span><br><span class="line">t[p].c=t[p*<span class="number">2</span>].c+t[p*<span class="number">2</span>+<span class="number">1</span>].c;</span><br><span class="line">t[p].ab=<span class="built_in">min</span>(t[p*<span class="number">2</span>].ab+t[p*<span class="number">2</span>+<span class="number">1</span>].b,t[p*<span class="number">2</span>].a+t[p*<span class="number">2</span>+<span class="number">1</span>].ab);</span><br><span class="line">t[p].bc=<span class="built_in">min</span>(t[p*<span class="number">2</span>].bc+t[p*<span class="number">2</span>+<span class="number">1</span>].c,t[p*<span class="number">2</span>].b+t[p*<span class="number">2</span>+<span class="number">1</span>].bc);</span><br><span class="line">t[p].abc=<span class="built_in">min</span>(&#123;t[p*<span class="number">2</span>].abc+t[p*<span class="number">2</span>+<span class="number">1</span>].c,t[p*<span class="number">2</span>].ab+t[p*<span class="number">2</span>+<span class="number">1</span>].bc,t[p*<span class="number">2</span>].a+t[p*<span class="number">2</span>+<span class="number">1</span>].abc&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(q\log n)$。</p><p>听说还有个矩乘做法，我还没看。</p><p>考点解析：DP（？）、线段树。</p><h2 id="Misaka">Misaka</h2><p>先判断出来哪些点能被覆盖。然后对所有金属导体按 $x$ 升序排序。</p><p>对于性质分，显然的点是，假设从左到右依次存在三个点 $A,B,C$ 需要被覆盖，那么不可能出现一个金属导体覆盖了 $A,C$ 而另一个金属导体覆盖了 $B$ 这种情况。换句话说，一个金属导体一定覆盖了一段连续的点，于是没有后效性，设 $f_{i,j}$ 为前 $i$ 个点且最后一个被选中的金属导体是 $j$，可以 DP。</p><p>对于全部的数据，直接多加一维，$f_{i,j,k}$ 表示前 $i$ 个点，最后一个被选中的上方的金属导体是 $j$，下方的是 $k$，就可以 DP。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=m;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=m;l++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dis2</span>(a,i,l)&gt;r*r)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(y[l]&gt;r)f[i][l][k]=<span class="built_in">min</span>(f[i][l][k],f[i<span class="number">-1</span>][j][k]+(l==j?<span class="number">0</span>:c[l]));</span><br><span class="line"><span class="keyword">else</span> f[i][j][l]=<span class="built_in">min</span>(f[i][j][l],f[i<span class="number">-1</span>][j][k]+(l==k?<span class="number">0</span>:c[l]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点解析：DP。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>神秘题 By qyc</title>
      <link href="/2024/07/08/problem/qyc1/"/>
      <url>/2024/07/08/problem/qyc1/</url>
      
        <content type="html"><![CDATA[<p>qyc 讲题汇总。先讲我听懂的。</p><h1>动态图连通性</h1><h2 id="题意简述">题意简述</h2><p>维护一张点数为 $n$ 的无向简单图，$m$ 次操作，加入或删除一条边及查询两个点是否连通。</p><p>$n\leq 5\times 10^3,m\leq 5\times 10^5$。</p><h2 id="解法一：线段树分治（离线）">解法一：线段树分治（离线）</h2><p>在时间轴上，每条边都有自己存在的时间段。我们在操作的时间轴上建立一棵线段树，每条边插入进其所完全包含的线段树上 $O(\log m)$ 个区间上。</p><p>在线段树上进行 DFS，同时维护一个表示连通块的并查集。这个并查集被要求是支持撤销操作的，为此我们使用按秩合并，每次修改时记录 <code>fa</code> 变化的那个点。每当我们进入一个线段树节点时，把节点里的所有边加入到并查集中，离开时撤销掉。当递归到叶子节点时计算询问。</p><p>容易证明这是正确的，因为当我们递归到叶子节点的时候，所有包含这一时间点的边都已经被加入到并查集中，同时撤销操作保证了没有包含这一节点的边不在并查集中。</p><p>分析一下时间复杂度。单个询问处理 $O(\log n)$，并查集合并 $O(\log n)$，撤销 $O(1)$。因为在线段树上，原来的 $O(m)$ 条边被拆分成了 $O(m\log m)$ 条边，每条边分别被合并撤销一次，所以是 $O(m\log n\log m)$ 的。</p><p>代码注意按秩合并别写假了，还有就是合并一条边时其可能已经被合并了，不能单单按照数量来进行撤销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(min(x,y),max(x,y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N],siz[N],st[M],top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">while</span>(fa[x]) x=fa[x]; <span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(siz[x]&gt;siz[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    st[++top]=x;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    fa[x]=y,siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[st[top]]!=st[top])siz[fa[st[top]]]-=siz[st[top]],fa[st[top]]=<span class="number">0</span>;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">conn</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pii&gt; t[M*<span class="number">4</span>];</span><br><span class="line">pii qr[M];</span><br><span class="line"><span class="type">bool</span> ans[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,pii e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        t[p].<span class="built_in">pb</span>(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m)<span class="built_in">update</span>(p*<span class="number">2</span>,l,m,L,R,e);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m)<span class="built_in">update</span>(p*<span class="number">2</span>+<span class="number">1</span>,m+<span class="number">1</span>,r,L,R,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(pii pa:t[p])<span class="built_in">merge</span>(pa.fi,pa.se);</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qr[l].fi)cout&lt;&lt;(<span class="built_in">conn</span>(qr[l].fi,qr[l].se)?<span class="string">&#x27;Y&#x27;</span>:<span class="string">&#x27;N&#x27;</span>)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">dfs</span>(p*<span class="number">2</span>,l,m),<span class="built_in">dfs</span>(p*<span class="number">2</span>+<span class="number">1</span>,m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t[p].<span class="built_in">size</span>();i++)<span class="built_in">quash</span>();</span><br><span class="line">&#125;</span><br><span class="line">map&lt;pii,vector&lt;<span class="type">int</span>&gt; &gt;ap;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>)qr[i]=<span class="built_in">mp</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> ap[<span class="built_in">mp</span>(x,y)].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(pair&lt;pii,vector&lt;<span class="type">int</span>&gt; &gt; p:ap)&#123;</span><br><span class="line">        <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:p.se)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lst)lst=x;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,m,lst,x<span class="number">-1</span>,p.fi),lst=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lst)<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,m,lst,m,p.fi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：LCT（在线）">解法二：LCT（在线）</h2><p>不会。</p><h1>CF1442D Sum</h1><h2 id="题意简述-2">题意简述</h2><p>给定 $n$ 个不降的数组 $a_i$，你需要执行 $k$ 次操作：选择其中一个数组的首个元素并将其拿出来。最大化拿出来元素的和。</p><p>$\sum |a_i|\leq 10^6,n,k\leq 3\times 10^3$。</p><h2 id="解法：线段树分治">解法：线段树分治</h2><p>注意到一个关键结论：如果你选了某个数组的元素，那么你要么把这个数组选完，要么因为剩余次数不够而选一个前缀。</p><p>所以可以把 $n$ 个数组看成 $n$ 个物品，费用是 $|a_i|$，价值是 $\sum a_i$。每次枚举没选完的那个数组，对剩下的数组做 $0/1$ 背包。但这样是 $O(nk^2)$ 的，显然过不了。</p><p>考虑到每次 $0/1$ 背包时，数据有很大一部分是重复的，所以我们考虑使用线段树分治来使数据利用最大化。</p><p>具体地，在 $1$ 到 $n$ 上建立线段树。进入一个节点时，从其父亲那继承背包的 DP 数组，把 $m+1$ 到 $r$ 的数组加入背包，向左递归，然后清空，把 $l$ 到 $m$ 的数组加入背包，向右递归。到达叶子节点时，除了这个节点的数组，其他的都已加入背包，所以直接枚举这个数组选了几个，跟背包的 DP 数组结合统计答案。正确性显然。</p><p>分析一下复杂度。把一个数组加入背包是 $O(k)$ 的。递归每一层都要加入 $n$ 个数组，一共有 $\log n$ 层，单个叶子节点统计答案复杂度是 $O(k)$ 的。所以总复杂度是 $O(nk\log n)$，可以通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,k,t[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s[N];</span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(k,t[l]);i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,a[k-i]+s[l][i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *f=<span class="keyword">new</span> <span class="type">int</span>[sum+<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(f,a,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(sum+<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=w[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">solve</span>(m+<span class="number">1</span>,r,f);</span><br><span class="line">    <span class="built_in">memcpy</span>(f,a,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(sum+<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=w[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">    <span class="built_in">solve</span>(l,m,f);</span><br><span class="line">    <span class="keyword">delete</span>[] f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">        s[i].<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t[i];j++)&#123;</span><br><span class="line">            <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">            s[i].<span class="built_in">pb</span>(s[i][j<span class="number">-1</span>]+x);</span><br><span class="line">        &#125;</span><br><span class="line">        v[i]=s[i][t[i]];</span><br><span class="line">        w[i]=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum=k;</span><br><span class="line">    <span class="type">int</span> *f=<span class="keyword">new</span> <span class="type">int</span>[sum+<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*(sum+<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n,f);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚树</title>
      <link href="/2024/05/10/algorithm/graph/virtual-tree/"/>
      <url>/2024/05/10/algorithm/graph/virtual-tree/</url>
      
        <content type="html"><![CDATA[<h1>引入</h1><p>给你 $n$ 个点的一棵树，每条边有边权。从中选取一些关键结点，你需要切断一些边，使得没有任何关键节点与 $1$ 号点联通，最小化切断边的总边权。</p><p>$O(n)$ 做法是显然的。考虑树形 DP。我们设 $f_u$ 为以 $u$ 为根的子树内（不包括 $u$）切断一些边使得没有任何关键结点与 $u$ 联通的边权和最小值。容易得到转移方程。</p><p>设 $v$ 是 $u$ 的一个儿子，$w$ 为 $u$ 到 $v$ 的边权。</p>若 $v$ 是关键结点，$f_u=f_u+w$，否则 $f_u=f_u+\min\{f_v,w\}$。<p>现在把问题升级一下。$q$ 组询问，每次给定一些关键结点，求答案。所有询问中关键结点个数的和与 $n$ 同阶。</p><p>我们把上面的算法跑 $q$ 次，就得到了一个 $O(nq)$ 的算法，这是远远不够的。</p><p>但是所有询问中关键结点个数的和与 $n$ 同阶，在关键点数量比较少的时候，总会有一些其他结点是无用的。我们有没有一种方法把这棵树的信息浓缩呢？答案是有的。</p><h1>虚树</h1><p>不要被名字吓到。所谓虚树，不过是一个重构树，在这个重构树上进行 DP 和在原树上 DP 是等价的。这个重构树上当然结点数量越少越好。</p><p>那么这个重构树上最少需要有哪些结点呢？先抛出结论：任意两个关键结点的 LCA 都是必须的。</p><p>为什么呢？我们在树上 DP 的过程其实是把一个个子树的信息合并。为了不错过任何子树合并的结点，自然是任意两个关键结点的 LCA。</p><p>当然，我们 $O(n^2\log n)$ 枚举任意两个关键结点的 LCA 肯定是不行的。所以我们需要一个快速构建虚树的算法。</p><h1>构建虚树</h1><p>我们先把原树的 dfn 求出来。考虑维护一个结点 dfn 值单调递增的单调栈。单调栈中每一个结点都是虚树上的点。</p><p>初始时，单调栈中有根节点 $1$，dfn 为 $1$。我们把关键结点按照 dfn 升序排序，依次考虑把每一个结点加入到虚树中。</p><p>假设当前考虑点 $u$，栈顶结点为 $t$，栈顶下面的一个结点是 $r$，我们求出 $p=\operatorname{LCA}(u,t)$。则一定有 $dfn_u&gt;dfn_p$。</p><ol><li><p>若 $t=p$，则我们直接把 $u$ 加入到栈中（也就是虚树中）。</p></li><li><p>否则，我们做如下处理：</p><ul><li><p>若 $dfn_r&gt;dfn_p$，则弹出栈顶直到 $dfn_r\leq dfn_p$。</p></li><li><p>此时，若 $r=p$，直接把 $t$ 弹掉然后加入 $u$ 即可。</p></li><li><p>否则，把 $t$ 弹出后，把 $p$ 和 $u$ 加入栈即可。</p></li></ul></li></ol><p>算法结束后，加入过栈的结点就是虚树中的结点。</p><p>下面我们来讨论这个算法的正确性。</p><p>当 $t=p$ 时，因为 dfn 递增，所以 $p$ 到 $u$ 的路径上没有其他关键结点，直接加入 $u$ 是正确的。</p><p>否则，我们要讨论两种情况：$p$ 加入过栈中，$p$ 没加入过栈中。</p><p>弹栈的过程，是为了寻找栈中相邻的两个点 $t$ 和 $r$，这两个点把 $p$ 夹在中间。</p><p>如果 $r=p$，也就是说 $p$ 加入过栈中，把 $r$ 弹掉后就变成了 $t=p$ 的情况。</p><p>如果，$r\neq p$，说明 $p$ 没加入过栈中，则我们需要把 $p$ 加入到栈中，也就是加入到 $r$ 和 $t$ 之间，然后把 $r$ 删除，就变成了 $t=p$ 的情况。</p><p>综上所述，这个算法是正确的。</p><p>分析时间复杂度。遍历每个点 $O(n)$，求 LCA 要 $O(\log n)$，单调栈均摊 $O(1)$，所以这个算法的时间复杂度是 $O(n\log n)$。</p><p>分析结点个数。通过算法，我们可以直观地发现，每两个 dfn 相邻的关键点最多可能会让一个 LCA 加入到虚树中，所以结点个数是 $O(n)$ 的。</p><p>我们在弹栈的时候，把次栈顶向栈顶连边即可得到虚树的图。</p><h1>解决问题</h1><p>回到原来的问题。我们建立好虚树，虚树中每条边的边权是原来树上两个点之间所有边的边权最小值，这是显然的，因为如果想要断边，只需要断最小的那条边就行。这可以轻松地用倍增维护。</p><p>每次询问在虚树上跑 DP，就 $O(n)$ 解决了这个问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树的直径</title>
      <link href="/2024/05/07/algorithm/graph/diameter/"/>
      <url>/2024/05/07/algorithm/graph/diameter/</url>
      
        <content type="html"><![CDATA[<h1>树的直径</h1><h2 id="定义">定义</h2><p>所谓树的直径，就是树上一条最长的链。</p><p>注意到这条链不唯一。</p><p>我决定在讲解例子的过程中穿插性质。</p><h2 id="直径的求法">直径的求法</h2><h3 id="两次搜索">两次搜索</h3><p>引理：<strong>一棵树上以任意一个点开始的最长简单路径的终点一定是直径两个端点之一</strong>。</p><p>证明：</p><blockquote><p>若不是端点，可分为两种情况讨论：<br>第一种，这条路径不与直径相交，则让直径改道过来这条路径显然比原来的直径更长，矛盾。<br>第二种，这条路径与直径相交，则让直径在交点处顺着这条路径走显然比原来直径更长，矛盾。<br>得证。</p></blockquote><p>所以我们可以两次搜索。</p><p>第一次任选一个点当做起点，找到距离这个点最远的一个点，则这个点一定是直径的其中一个端点。</p><p>第二次再把这个端点当做起点，找到另一个端点。</p><p>这种方法的好处在于可以求具体方案。但是注意一棵树可能有多条直径，且这种方法不适用于负权边存在的情况。</p><h3 id="树形-DP">树形 DP</h3><p>在树形 DP 中，我们对于每个点维护两个值：在以这个点为根的子树中，从这个点往下走的链的最长长度和次长长度。转移直接由儿子的最长长度加上到儿子的边权即可。</p><p>直径就是每个点最长长度和次长长度加起来的最大值。</p><p>这种方法可以用于负权边情况。</p><h2 id="SDOI2011-消防（树网的核-加强版）">[SDOI2011] 消防（树网的核 加强版）</h2><p>题意不再赘述。</p><p>首先说说为什么这条路径肯定在直径上。我们只要证明当这条路径不在直径上的时候，不比在直径上更优即可。</p><blockquote><p>依然分两种情况。<br>首先，在这棵树上，存在一个点，使得它到直径两端的距离的最大值最小（也即到其他任何点的距离最大值最小）。这个点一定是在直径上的。<br>当这条路径完全不在直径上时，还不如直接选取这个点更优，而这个点的路径长度是 $0$，肯定比这个路径更优。<br>当这条路径有一部分在直径上时，直接把不在直径上的部分去掉，让它变成一条完全在直径上的路径，答案不会变。因为如果答案变了，说明把这条路径不在直径上的部分去掉后，路径的端点顺着原路径方向的距离最大值比到直径端点的距离长，与 “一棵树上以任意一个点开始的最长简单路径的终点一定是直径两个端点之一” 相矛盾。</p></blockquote><p>所以我们只需要考虑这条路径在直径上即可。</p><p>考虑对于一条直径上的路径，如何计算它到各点路径长度的最大值。</p><p>首先，这条路径的左右端点到直径的左右端点的距离可能成为最大值，这是显然的，而且我们不用考虑左右端点到除了直径端点以外的情况，因为 “一棵树上以任意一个点开始的最长简单路径的终点一定是直径两个端点之一”。</p><p>我们给直径做一个距离前缀和，就能快速求出来这个距离。</p><p>其次，路径上中间的每个点还可以往直径的侧边走，我们对于直径上每个点预处理出来往侧边走的最大值。</p><p>最后考虑如何维护路径。</p><p>我们使用双指针来维护 “路径长度不超过 $s$” 这一条件，用单调队列来维护路径上点往侧边走的最大值即可。最终 $O(n)$。</p><h1>树的半径</h1><p>还是挺重要的。</p><h2 id="定义-2">定义</h2><p>在一棵树中，找到一个点（中心）使得这个点到树的其他所有点的距离最大值最小，则这个最大值就是树的半径。</p><h2 id="求法">求法</h2><p>先用树形 DP 求直径把 $f_u,g_u$ 求出来。</p><p>定义 $h_u$ 为 $u$ 这个结点往上走的最大距离。转移考虑两种情况：$u$ 到父亲继续往上走，还是 $u$ 到父亲然后到 $u$ 的兄弟，两种情况取 $\max$ 即可。</p><p>半径就是所有 $\max\{f_u,h_u\}$ 的最小值。</p><h2 id="直径的合并">直径的合并</h2><p>挺有意思的。标题没打错，就是 <strong>直径</strong> 的合并。</p><p>对于两棵树，把它俩合并之后直径的长度最小是多少？</p><p>两种情况：</p><p>第一种情况，是原来两棵树的直径不变。</p><p>第二种情况，两棵树的中心连起来，最终的直径就是两棵树的半径和连起来这条边的边权加起来。</p><p>很显然，不多说了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流模型 · 最小路径覆盖 &amp; 拓展</title>
      <link href="/2024/04/26/algorithm/graph/flow/zxljfg/"/>
      <url>/2024/04/26/algorithm/graph/flow/zxljfg/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>在一个 DAG（有向无环图中），选择其中的一些简单路径，若图中每个点都恰好在其中一条路径上，则称这些路径是一个<strong>路径覆盖</strong>。</p><p>所有路径覆盖中，路径条数最小的路径覆盖叫做<strong>最小路径覆盖</strong>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/q46ij4r4.png" alt=""></p>例如在上图中，$\{\{1\},\{2,3\},\{4,5\}\}$ 是一个路径覆盖，$\{\{1,2,3,4,5\}\}$ 是一个最小路径覆盖，只用了一条路径。<p>任务是找出 DAG 上的最小路径覆盖，且输出方案。</p><h1>建模</h1><p>考虑二分图最大匹配。</p><p>我们对原图中每个点 $u$ 拆成两个点，记为左部点 $L(u)$ 和右部点 $R(u)$。</p><p>对于原图中每条边 $(u,v)$，连接 $L(u)$ 到 $R(v)$。</p><p>则答案为原图中点数减去最大匹配数。</p><h1>正确性</h1><p>假设开始时图上的每个点都自成一条路径，我们要做的是尽可能多地把路径合并。</p><p>考虑一下路径合并的隐藏条件：</p><p>首先，路径合并是可以传递的，简单来说，如果 $x$ 能跟 $y$ 合并，$y$ 能跟 $z$ 合并，那么 ${x,y,z}$ 可以合并成一条路径。所以我们可以只考虑点与点之间的合并关系，再利用传递性求方案。</p><p>其次，每条路径只能向一个路径合并，也只能被一条路径合并。</p><p>这下就好办了。在我们构造的二分图中，如果一条边 $(L(u),R(v))$ 被选中了，那么说明在原图中点 $u$ 要向点 $v$ 合并，同时其它在二分图中与其它 $L(u)$ 相连的边都不能被选中，对应着在原图中一个点仅能选择另外一个点进行合并。</p><p>此时的最大匹配就是可以合并的数量，用总的点数减去它就是答案。</p><p>至于方案数，可以根据上面所说的，用并查集简单维护即可。</p><p>二分图的最大匹配我们可以选择用最大流来求。跑完最大流后，如果一条连接 $L(u)$ 和 $R(v)$ 的边容量为 $0$，则说明这条边在二分图中被选中了。</p><h1>拓展 1 · 最小链覆盖</h1><p>所谓最小链覆盖，无非是把路径改为了链。对应的，DAG 上的每一个点可以被重复覆盖多次。</p><p>此时我们对 DAG 用 Floyd 进行传递闭包，得出每个点相互可不可达，再根据这个跑最小路径覆盖即可。</p><h1>拓展 2 · DAG 最大独立集</h1><p>顾名思义，我们要在 DAG 中选取一些点，使得任意两个点都不能从其中一个点到另外一个。</p><p>此时我们引入偏序集。</p><h2 id="偏序集">偏序集</h2><h3 id="偏序集和偏序关系">偏序集和偏序关系</h3><p>我当然不会上来就放形式化的东西，否则你们还有什么来看的必要呢？</p><p>所谓偏序集，指的是一个集合和一个关系的共同体。</p><p>那么何为关系？举个最简单的例子，“$\leq$”（小于等于号）是一个关系。</p><p>现在我们给偏序集做一个定义，百度说：</p><blockquote><p>若在集合 $A$ 上给定一个偏序关系 $\leq$ ，则称集合 $A$ 按偏序关系 $\leq$ 构成一个偏序集合，集合 $A$ 和偏序 $\leq$ 一起称为偏序集，记作 $(A,\leq)$。</p></blockquote><p>不懂。什么是偏序关系？</p><blockquote><p>设 $R$ 是集合 $A$ 上的一个关系，如果 $R$ 是<strong>自反的</strong>、<strong>反对称</strong>的和<strong>可传递</strong>的，则称 $R$ 是集合 $A$ 的偏序关系，简称偏序，记作“$\leq$”。</p></blockquote><p>现在对偏序关系中的一些名词做一些解释：</p><p>自反：$\forall a\in A,a\leq a$</p><p>反对称：$\forall a,b\in A, $ 若 $a\leq b$ 且 $ b\leq a,$ 则 $a=b$</p><p>传递性：$\forall a,b,c\in A,  $若$ a\leq b $且$ b\leq c, $则$ a\leq c$</p><p>不妨把这个小于等于号真的当做一个小于等于号来看待，则 $\leq$ 是 $\mathbb{R}$ 的偏序关系。</p><p>所以我们可以说 $(\mathbb{R},\leq)$ 是一个偏序集。</p><h3 id="元素之间的可比关系">元素之间的可比关系</h3><p>设 $(P,\leq)$ 是一个偏序集。</p><p>$a,b\in P$，若 $a\leq b$ 或 $b\leq a$，则我们称 $a$ 与 $b$ 是可比的。无需解释。</p><p>否则我们说 $a$ 与 $b$ 不可比，记作 $a\mid\mid b$。</p><h3 id="延伸">延伸</h3><p>设 $(P,\leq)$ 是一个偏序集，$\geq$ 是一个关系。</p><p>若对于 $\forall x,y\in P$，有 $x\leq y \Leftrightarrow y\geq x$，则我们称 $\geq$ 是 $\leq$ 的逆关系，记作 $\leq^{-1}$。$\leq^{-1}$ 是 $\leq$ 的逆。无需解释，符号已经说的很明白了。</p><p>那么，若 $(A,\leq)$ 是一个偏序集，$(A,\leq^{-1})$ 也是一个偏序集。这是显然的。$(A,\leq^{-1})$ 称作 $(A,\leq)$ 的对偶，简记作 $A^{-1}$。</p><h3 id="偏序集的哈塞图">偏序集的哈塞图</h3><p>所谓哈塞图，不如将其理解为一个 DAG。</p><p>设 $(P,\leq)$ 是一个偏序集，我们对于 $\forall a,b(a\neq b)\in P,$ 若 $a\leq b$ 则从 $b$ 到 $a$ 连一条边，最后显然会形成一个 DAG。（根据传递性可得到图中没有环）</p><h3 id="链、反链、Dilworth-定理">链、反链、Dilworth 定理</h3><p>偏序集 $(P,\leq)$ 上的一个链是一个元素集合 $S \subset P$，其中 $\forall a,b\in S,a$ 与 $b$ 可比。</p><p>反链就是反着来，也是一个元素集合 $S\subset P$ 其中 $\forall a,b\in S,a\mid\mid b$。</p><p>需要注意的是，链在 DAG 中并不是一条路径，而是一条路径上可以不连续的几个点，但是在后续我们为了方便，把链看成 DAG 上的一条路径，反链就是一些 DAG 上互相不可达的点。</p><p>接下来我们引入偏序集的链划分。</p><p>所谓链划分，就是一些链的集合，使得偏序集的每一个元素都在其中至少一条链上。</p><p>最小链划分就是用最少的链来把整个偏序集覆盖，对应到 DAG 上就是最小链覆盖。</p><p>Dilworth 定理指出，<strong>偏序集中的最长反链长度等于最小链划分个数</strong>。</p><p>证明略，感兴趣的可以尝试对偏序集的大小进行归纳证明。</p><h2 id="模型">模型</h2><p>看到这里是不是恍然大悟了，我们在原 DAG 上求最小链覆盖，得到的答案就是最大独立集大小。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流模型 · 最大权闭合子图</title>
      <link href="/2024/04/25/algorithm/graph/flow/zdqbhzt/"/>
      <url>/2024/04/25/algorithm/graph/flow/zdqbhzt/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>我们先来定义什么是闭合子图。</p><p>通俗地讲，在一个有向图中，我们选择一些点作为一个点集。若这个点集中任何一个点所能到达的所有点都在这个点集中，我们称这个点集是一个<strong>闭合子图</strong>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/q46ij4r4.png" alt=""></p><p>例如，在上图中，$\{5\},\{2,3,4,5\},\{1,2,3,4,5\}$ 都是这个图的闭合子图。而 $\{2,4,5\}$ 则不是，因为 $3$ 可以到达 $4$，而 $4$ 不在这个点集中。</p><p>现在，每个点有一个点权 $w_i$，$w_i$ 可以是负数，我们要选择一个<strong>最大权闭合子图</strong> $S$ 来最大化 $\sum_{u\in S}w_u$，即选择一个点权和最大的闭合子图。</p><h1>建模方法</h1><p>我们考虑把它转化成网络流中的最小割来解决。</p><p>具体地，建立超级源点 $S$ 和超级汇点 $T$。</p><ol><li><p>对于原图中的边，我们保留，并把其容量设为 $\inf$。</p></li><li><p>对于每个原图中的点 $u$：若 $w_u&gt;0$ 则从 $S$ 向 $u$ 连一条容量为 $w_u$ 的边。若 $w_u&lt;0$ 则从 $u$ 向 $T$ 连一条容量为 $-w_u$ 的边。若 $w_u=0$，我们不管他。（也可以管，但是容量为 $0$ 就相当于没有边）</p></li><li><p>我们跑出这个网络的最小割，其容量记为 $c$，则最大权闭合子图的权值和就是 $\sum_{w_u&gt;0}w_u-c$。</p></li></ol><h1>正确性</h1><p>首先，最小割一定不会割掉原图中的边，因为这些边的容量是 $\inf$，割掉它还不如把其它所有边割掉。</p><p>其次，我们是不会主动选择一个负权点 $u$ 的。若选择了这个点，则其在原图中所有能到达的点都被选择了，那还不如选择 $u$ 的所有儿子而不选择 $u$ 更优。</p><p>如果我们割掉了一条从 $S$ 到正权点 $u$ 的边，则说明我们不选择 $u$。</p><p>如果我们割掉了一条从负权点 $v$ 到 $T$ 的边，则说明我们选择 $v$。</p><p>每个点都只有选或者不选两种情况，所以，<strong>一个割一定对应一个子图</strong>。</p><p>对于一条从 $S$ 连向正权点 $u$ 的边，若不割掉它，则说明我们选择了原图中 $u$ 这个点，进而选择了 $u$ 的所有能到达的点 $V$。$V$ 中如果有负权点，那么必须割掉这些负权点到 $T$ 的边（也即选择这些负权点），否则存在从 $S$ 到 $T$ 的路径，不能形成一个割。</p><p>所以，<strong>一个割一定对应一个闭合子图</strong>。</p><p>对于一条从 $S$ 连向正权点 $u$ 的边，若不割掉它，则说明我们选择了原图中 $u$ 这个点，进而选择了 $u$ 的所有能到达的点 $V$。$V$ 中如果有正权点，则 $S$ 到这些点的边一定不会割掉（对应着我们选择了这些点），因为在割掉 $V$ 中所有负权点到 $T$ 的边的前提下，这些点不用割掉任何其它的负权点到 $T$ 的边，因此不割肯定比割了要更优。</p><p>若对于一个负权点 $v$，其所有的前驱正权点到 $S$ 的边都被割掉了，那么就不用割掉 $v$ 到 $T$ 的边了，因为显然没有任何点能选择 $v$。</p><p>以上的这些只是为了加深理解，<strong>最小割一定对应最大权闭合子图</strong>。</p><p>最后，答案是 $\sum_{w_u&gt;0}w_u-c$ 的原因也就呼之欲出了：</p><p>$c$ 中包含了 $S$ 到正权点的边的容量，即不选这个正权点，所以肯定要从正权点的和中减去。</p><p>同时它又包含了负权点到 $T$ 中的容量，即选择这个负权点，因为权值是负的，所以肯定要减去。（与前文 $w_u&lt;0$ 时边的容量设成 $-w_u$ 形成呼应）</p><p>关于具体方案，根据上文所说的 割不割 与 选不选 的关系可以轻松求得。</p><p>$$Q.E.D.$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串·SA</title>
      <link href="/2024/04/17/algorithm/string/sa/"/>
      <url>/2024/04/17/algorithm/string/sa/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><p>我们现在有一个长为 $n$ 的字符串 $s$，我们定义这个字符串的后缀 $i$ 表示 $s[i,n]$。</p><p>现在，我们要对 $s$ 所产生的 $n$ 个后缀进行排序，得到第 $i$ 个后缀是第几名，我们记其为 $rk_i$。同时，我们还能得到第 $i$ 名的是哪个后缀，记为 $sa_i$。</p><h1>如何求 SA</h1><h3 id="暴力">暴力</h3><p>我们有一种极其暴力的做法，把这 $n$ 个后缀存下来，再排序。总共有 $O(n\log n)$ 次比较，每次比较最坏 $O(n)$，则复杂度是 $O(n^2\log n)$，遥遥落后。</p><h3 id="倍增法">倍增法</h3><p>我们换一种思路：每次计算长度为 $w$ 的所有子串的排名，这样就可以通过合并排名来统计答案，为此，我们修改一下定义：</p><p>假设当前考虑的子串长度为 $w$，对于在结尾不足 $w$ 位的子串，我们给它补上当前字符集中最小的字符（实现中是值 $0$）。这样，我们就一共有 $n$ 个长为 $w$ 的子串了。</p><p>$rk_i$ 表示 $s[i,i+w-1]$ 在这 $n$ 个长为 $w$ 的子串中的排名。$sa_i$ 类似。</p><p>我们从 $w=1$ 的情况开始考虑。此时显然我们可以轻而易举地计算出 $rk_i$，然后根据 $rk$ 来计算 $sa$。</p><p>当我们考虑到 $w=2^p$ 时，假设我们已经有了 $w’=2^{p-1}$ 时的 $rk$ 和 $sa$。因为 $s[i,i+w-1]=s[i,i+w’-1]+s[i+w’,i+w-1]$，所以我们可以根据 $rk_i$ 和 $rk_{i+w’}$ 来进行一个排序。</p><p>先放一下代码，结合代码讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> w,rk[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[x]==rk[y])<span class="keyword">return</span> rk[x+w]&lt;rk[y+w];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> rk[x]&lt;rk[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sa[i]=i,rk[i]=s[i];</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(sa+<span class="number">1</span>,sa+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line">            <span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在上面的这个实现中，最外层 for 循环开始时，$rk$ 的值就是子串长度为 $w$ 的值，而 $sa$ 的值是子串长度为 $w/2$ 的时候的值。每次 for 循环，先根据当前的 $rk$ 来把 $sa$ 更新到当前状态，再根据 $sa$ 计算出下一个 $rk$。</p><p>根据 $rk$ 来给 $sa$ 排序时（也就是 sort 函数），此时的 $sa$ 数组里什么值其实是无关紧要的，只要是任意一个 $n$ 的排列就行（因为关键字和 $sa$ 没关系），我们以 $rk_{sa_i}$ 为第一关键字，$rk_{sa_i+w}$ 为第二关键字。原因是在子串 $s[sa_i,sa_i+2w]$ 中，根据字符串比较的原则，要先比前面的 $s[sa_i,sa_i+w]$ 的部分。</p><p>后面根据 $sa$ 来更新 $rk$ 时，注意当两个子串相等时他们的 $rk$ 也要相等。</p><p>倍增 $O(\log n)$，排序 $O(n\log n)$，总时间复杂度 $O(n\log^2n)$。</p><h3 id="基数排序优化">基数排序优化</h3><p>在给 $sa$ 排序的过程中，我们可以使用基数排序来优化到 $O(n)$ 排序。</p><p>首先我们要了解基数排序，而我们所使用的基数排序又依赖于计数排序，所以我们先讲讲计数排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[a[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)ans[i]=cnt[a[i]]--;</span><br></pre></td></tr></table></figure><p>十分的简洁明了。其中 $a$ 是待排序数组，$m$ 是值域，$ans_i$ 表示 $a_i$ 的排名。值得注意的是，这是一个稳定的排序算法，因为统计答案的时候我们采用了原数组倒序的方式。如果 $m=n$，那么 $ans$ 就是排序之后的答案数组。时间复杂度显然是 $O(n+m)$。</p><p>下面我们介绍一下基数排序。这是一个多关键字的排序，我们现在有 $n$ 个元素，每个元素有 $2$ 个关键字。$a_i$ 表示第 $i$ 个元素的第 $1$ 个关键字，$b_i$ 是第二个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[b[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)tmp[i]=cnt[b[i]]--;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[tmp[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)ans[i]=cnt[tmp[i]]--;</span><br></pre></td></tr></table></figure><p>为什么这样是正确的呢？第一次我们先对第二关键字排序。第二次排序的时候，当第一关键字不同，此时可以被正确排序。而当第一关键字不同的时候，因为计数排序是稳定的排序，所以我们原先保留的第二关键字的顺序不会变，就完成了排序。</p><p>把这项技术运用到我们的倍增法里，我们就得到了一个 $O(n\log n)$ 的求后缀数组的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,rk[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>],id[N*<span class="number">2</span>],cnt[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">128</span>;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[i]]--]=i;</span><br><span class="line">    <span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(oldrk[sa[i<span class="number">-1</span>]]==oldrk[sa[i]])rk[sa[i]]=p;</span><br><span class="line">        <span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;n;w&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i+w]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)id[cnt[rk[i+w]]--]=i;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[id[i]]]--]=id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line">            <span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了帮助理解，我决定还是讲解一下。</p><p>首先我们计算出了子串长度为 $1$ 时的 $sa$，再据此计算出 $rk$ 的数值版本。在 for 循环中，我们先根据第二关键字计数排序（也就是 $rk_{sa_i+w}$）。排完序后的 $id_i$ 表示 $s[j+w,j+2w-1]$ 在 $j=1,2,3,\cdots,n$ 这 $n$ 个子串中的排名为 $i$ 的 $j$ 的值。然后再根据第一关键字，以 $id$ 倒序的顺序来进行计数排序。这一次计数排序保证了在 $rk_i$ 不同的时候，较小的排在前面。而 $id$ 倒序的顺序保证了在 $rk_i$ 相同的时候，$rk_{i+w}$ 较小的能排在前面。</p><h3 id="常数优化">常数优化</h3><p>我们已经写出了 $O(n\log n)$ 的算法，但这份代码的常数巨大，需要优化常数。</p><p>先优化几个比较显然的点。</p><ol><li>我们每次计数排序的值域不用开到 $n$，由代码可知上一次的 $p$ 就是值域。</li><li>当计算完 $rk$ 后，若 $p=n$，则说明算法完成了。因为此时 $rk$ 两两不同，再往后排也不会有新的结果。</li></ol><p>然后思考一下对第二关键字排序的实质。</p><p>我们发现，对于 $i+w&gt;n$ 的部分，$rk_{i+w}$ 实质上是等于 $0$ 的，因此，这一部分会被放在 $id$ 的最前面。</p><p>在对第二关键字排序的时候，此时的 $sa$ 数组其实是上一次的保留结果，此时 $sa_i$ 表示所有长为 $\frac{w}{2}$ 的子串中，第 $i$ 名的起始位置。我们直接从第 $1$ 名开始，如果 $sa_i&gt;w$，我们直接把 $sa_i-w$ 放进 $id$ 即可。此时我们发现，$sa_i$ 最大是 $n$，所以 $sa_i-w$ 最大是 $n-w$，正好跟前面对上了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> p,m,rk[N*<span class="number">2</span>],sa[N*<span class="number">2</span>],oldrk[N*<span class="number">2</span>],id[N*<span class="number">2</span>],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(oldrk[x]==oldrk[y]&amp;&amp;oldrk[x+w]==oldrk[y+w])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    m=<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[i]]--]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;;w&lt;&lt;=<span class="number">1</span>,m=p)&#123;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++)id[++cur]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(sa[i]&gt;w)id[++cur]=sa[i]-w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)cnt[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cnt[rk[id[i]]]--]=id[i];</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)oldrk[i]=rk[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])rk[sa[i]]=p;</span><br><span class="line">            <span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==n)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graphviz 图论画图工具笔记</title>
      <link href="/2024/04/12/graphviz/"/>
      <url>/2024/04/12/graphviz/</url>
      
        <content type="html"><![CDATA[<h1>简介</h1><p>如题，是一个可以便捷生成图论中各种图的工具。</p><h1>下载 &amp; 安装</h1><p><a href="https://graphviz.org/download/">链接</a></p><p>自己选适合自己操作系统的版本。</p><p>安装以 Windows 为例，其实也没什么要注意的点，把 “Add Graphviz to the system PATH” 中的任意一个勾上就行了。</p><p>命令行试试 <code>dot -V</code>，如果有输出说明安装成功，没输出检查一下勾没勾上上述选项。</p><h1>配置</h1><p>以 VSCode 为例。</p><p>插件搜索 Graphviz，安装 Graphviz Interactive Preview 和 Graphviz (dot) language support for V。</p><p>前者是用于实时生成预览图，后者提供语法高亮。</p><h1>教程</h1><p>Graphviz 源文件的扩展名是 <code>.dot</code>。所以我们在 VSCode 中新建一个 <code>.dot</code> 文件。你会发现右上角有一个小图标，点开它，就有了预览界面。</p><p>先试着写一点简单的图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    A -&gt; B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>digraph</code> 定义了一个有向图，这个有向图里有 <code>A</code> 和 <code>B</code> 两个结点，其中 <code>A</code> 向 <code>B</code> 连了一条有向边。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    A [color = red, shape = box, style = dashed]</span><br><span class="line">    B [color = blue, shape = ellipse, style = bold]</span><br><span class="line">    A -&gt; B [label = &quot;A to B&quot;, color = red, style = dashed]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来一一解读一下。<br>第一行我们定义了一个有向图，这和上个示例一样。<br>第二行我们定义了一个结点 <code>A</code>，它有一些属性，如：红色，方形，虚线。<br>第三行我们定义了一个结点 <code>B</code>，它有一些属性，如：蓝色，椭圆形，加粗线。<br>第四行我们定义了一个有向边 <code>A -&gt; B</code>，它的附加文本是 <code>A to B</code>，其他同上。</p><p>详细的介绍可以参照<a href="https://www.graphviz.org/doc/info/attrs.html">官方文档</a>。</p><p>根据以上内容，我们可以轻松地写出来一个通过一些字符串来构建可视化 Trie 树的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> e[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[p].e[c])t[p].e[c]=++tot;</span><br><span class="line">        p=t[p].e[c];</span><br><span class="line">    &#125;</span><br><span class="line">    t[p].s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[p].e[i])&#123;</span><br><span class="line">            cout&lt;&lt;p&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>&lt;&lt;t[p].e[i]&lt;&lt;<span class="string">&quot; [label = \&quot;&quot;</span>&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i)&lt;&lt;<span class="string">&quot;\&quot;]&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(t[p].e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;out.dot&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;digraph&#123;&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(t[i].s)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; [style = bold]&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于输出的文件，我们可以通过 <code>dot -Tpng 1.dot -o 1.png</code> 来把 <code>.dot</code> 文件转化成 <code>.png</code> 图片。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串·KMP</title>
      <link href="/2024/04/03/algorithm/string/kmp/"/>
      <url>/2024/04/03/algorithm/string/kmp/</url>
      
        <content type="html"><![CDATA[<h1>定义</h1><h2 id="约定记号">约定记号</h2><p>$s[l,r]$ 代表从 $l$ 到 $r$ 的子串。</p><h2 id="pi-函数">$\pi$ 函数</h2><p>对于一个字符串 $s$，它的 $\pi$ 函数是它的前缀和后缀相等的最长长度。</p><p>$$ \pi=\max_{s[1,i]=s[n-i+1,n]} i $$</p><p>进一步，我们定义 $\pi_i$ 是字符串前 $i$ 个字符组成的子串的 $\pi$ 函数值。特别的，定义 $\pi_1 =0$。</p><p>下面我们考虑如何求出 $\pi$ 数组。</p><p>对于 $\pi_1=0$ 是确定的，考虑递推。</p><p>假设我们当前求出了 $\pi_1,\pi_2,\cdots,\pi_i$ 要求出 $\pi_{i+1}$。</p><p>有一个特殊情况，如果 $s[\pi_i+1]=s[i+1]$，那么 $pi_{i+1}=\pi_i+1$。</p><p>根据 $\pi$ 函数定义，$s[1,\pi_i]=s[i-\pi_i+1,i]$，那么如果 $s[\pi_i+1]=s[i+1]$，就有了 $s[1,\pi_i+1]=s[i-\pi_i+1,i+1]$，进而有 $\pi_{i+1}=\pi_i+1$。</p><p>下面考虑当 $s[i+1]\ne s[\pi_i+1]$ 时的情况：</p><p>还是一样的，$s[1,\pi_i]=s[i-\pi_i+1,i]$，$\pi_{i+1}$ 肯定不比 $\pi_i$ 大，所以我们要在 $[1,\pi_i]$ 中找到一个最大的 $j$ 使得 $s[i-j+1,i+1]=s[1,j+1]$，此时 $\pi_{i+1}=j+1$。</p><p>注意到此时 $s[1,j]$ 是 $s[1,\pi_i]$ 的前缀，$s[i-j+1,i]$ 是 $s[i-\pi_i+1,i]$ 的后缀，又因为 $s[1,\pi_i]=s[i-\pi_i+1,i]$，所以 $[i-j+1,i]$ 是 $s[1,\pi_i]$ 的后缀。</p><p>当满足 $s[i-j+1,i+1]=s[1,j+1]$ 且 $j$ 最大时，也就是 $s[1,\pi_i]$ 的前缀和后缀相等且长度最长的时候，我们发现此时正好和 $\pi$ 的定义对上了，那么此时的 $j$ 就是 $\pi_{\pi_i}$。</p><p>若此时 $s[j+1]=s[i+1]$，那么 $\pi_{i+1}=j+1$。否则一直这么找下去，直到真的没有相同的前后缀。</p><p>求 $\pi$ 数组代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=pi[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])j++;</span><br><span class="line">    pi[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP-算法">KMP 算法</h2><p>该算法用于解决这样的问题：</p><p>给定文本串 $s$ 和模式串 $t$，求 $s$ 中所有出现的 $t$ 的位置。</p><p>我们可以使用这样的方法来解决：令 $f=s+c+t$，其中 $c$ 是不属于字符集的一个字符，求 $f$ 的 $\pi$ 数组，若 $\pi_i=len_t$，则在以 $i$ 为结尾的位置匹配上了。代码略。</p><p>另外还有一种不用显式建出字符串 $f$ 的方法：我们先跑出 $t$ 的 $\pi$ 数组，然后直接匹配，过程类似于求 $\pi$ 数组，具体见代码，其中 $mth_i$ 表示到 $s_i$ 匹配了多少位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j=mth[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;t[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">    <span class="keyword">if</span>(t[j+<span class="number">1</span>]==s[i])j++;</span><br><span class="line">    mth[i]=j;</span><br><span class="line">    <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">        <span class="comment">// 此时匹配上了</span></span><br><span class="line">        j=pi[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>联合省选2024·游记</title>
      <link href="/2024/04/02/article/lhsx2024/"/>
      <url>/2024/04/02/article/lhsx2024/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>关于 CSP 没什么好说的，A 切了，B 35pts 暴力之后跑路。</p><p>C 一看，第一次遇见大模拟，有点害怕，草草写了个 15pts 性质分跑路了，然后一直在做 D 题。</p><p>总之就是很飞舞，D 题暴力挂了，C 挂了 10 pts，最后只有 140 分。</p><p>压线 6 级勾，有点惊喜但不多，可以参加 NOIP。</p><h3 id="NOIP"><a href="#NOIP" class="headerlink" title="NOIP"></a>NOIP</h3><p>A 切了，B 看了之后有点害怕，以为是什么 Tarjan 图论题。</p><p>因为我 Tarjan 学得不好所以打了个部分分草草了事</p><p>我为什么没看见暴力分？我为什么没看见暴力分？我为什么没看见暴力分？</p><p>C 题更害怕，做了个特殊性质。</p><p>我为什么没看见暴力分？我为什么没看见暴力分？我为什么没看见暴力分？</p><p>D 题，是个 DP，感觉很可做诶，写了个 $O(n^2)$ DP，后面不会优化了，跑路。</p><p>最后只有 146 分，大失败，这也是为什么我在这之后的比赛基本不想正解，只打部分分。</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>是一个省选模拟赛。</p><p>上来看 A，什么抽象题面，转去看 B，发现有 59 分是送的，赶紧写了。</p><p>读了 A，暴力思维难度较大，于是看 C，发现有 21 分是送的，赶紧写了。</p><p>后面就是 A 和 C 交替进行，C 写了一个类似于分层图 + 双端队列 BFS 的东西但是复杂度假了。A 分析了一会感觉不会就摆了。</p><p>最后 80 分，大众分，对得起我的水平。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>依然是省选模拟赛，但是是 OI 赛制。</p><p>A 题奇怪数学题，开场 10 min 就有人说切了，有点害怕，后来乱猜了结论之后就过了。</p><p>B 题像 DP，糊了一个 $O(qn^3)$ DP，期望得分 19 分。</p><p>C 题像奇怪 DS 题，感觉很繁琐，而且暴力的 $O(n!)$ 不给过，于是思考特殊性质，但是不会，去看 B。</p><p>B 还是不会，去看 C，此时恍然大悟就开始写，结果最后没时间调了。</p><p>评测，A 没挂分，RP—，B甚至多得了17分，这下 RP 掉光了，C 没得分，最后是获得了我 OI 生涯的第一个 rk1，令人感慨。</p><p>最后发现 BC 都是 DP，吓人。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>此时我已经狂暴 whk 一周了，感觉很颓。又因为作业比较多，几乎没早睡过，比较困。晚上去试机有点晕车。</p><p>到达山师二附中，面到了 <a href="https://www.luogu.com.cn/user/679581">MrPython</a> 老师。很可爱，是 Linux 爷，但是他走错考场，于是就有了我们戏剧性相见的一幕。</p><p>面基完赶紧去考场，坐下之后不知道敲什么，看左边在敲一个不知道是什么的树上算法，右边在敲 Dinic，我就敲了一个树剖，结果发现挂了一个点，不想调了就没调。<br>发现老头、吴爷、豆、王老师都在一个考场，于是就去聊天。豆在测试快读快写和 cin cout 的速度差异，运用了控制变量法。</p><p>发现吴老师和 nrd 一个考场，想去看，但是太远了没去，只能羡慕 Linux 爷了。</p><p>回家看了看树剖为什么挂了，发现是取模问题，看了一个关于 pbds 的博客，转念一想不会出板子题，就没背。</p><p>明天准备罚坐，放张图片镇楼。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nhc1vva8.png" alt=""></p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上到了考场门口，先和各路大神交流一下，进考场之后基本在发呆。</p><p>公布密码之后先看题，A 抽象，B 抽象，C 更抽象。按照以往惯例我先开了 A。</p><p>推了下式子，发现 $\sum x_{i\bmod n}$ 可以 $O(1)$ 求，然后又发现最终答案和每个 $x’_i$ 的具体取值无关，于是想到了二分答案。</p><p>二分写完之后调样例，第二个死活调不过去，于是在大概十点半的时候放弃了，去看 B，发现 B 有 12 分是送的，赶紧写了，调了一会过了样例。</p><p>看 C，感觉题面极其抽象，而且要满足的限定条件很多，感觉写暴力有点不划算，回去调 A。</p><p>偶然的一个机会我输出了一个中间变量，发现我错的点都有一个明显的共同特征：二分域上只有一个点满足要求。进一步结合数据分析，发现此时 $x$ 正好是 $x_0$ 的倍数，于是开心写了个特判然后过了第二个样例。</p><p>第三个样例，麻烦，又有很多不对的地方。于是我拓展特判到了 $n&gt;1$ 的情况，此时码长来到了 3.5k，发现死活过不去。</p><p>调了半个小时，果断放弃了 A，去看 B 特殊性质。感觉像 01trie，但是我仅限于听过这个东西，用贪心打了个 B 性质，发现错的离谱，于是就放弃了。再去看 C 还是那么的抽象，于是又回去看 A 了。</p><p>开始一个个排查着样例里出错的测试点，前几个还好，是因为特判的边界情况，但是我突然发现了一个样例有点不对，定睛一看：</p><p>卧槽，原来是没有单调性的。</p><p>崩溃了。</p><p>保护了一下一些特殊性质分之后就摆了，C 决定输出 0，此时还剩 20 min。</p><p>还没出考场就去问别人 A 怎么做的，发现吴爷也是二分，王老师写的分讨但是没过，老头分讨把 A 切了。</p><p>下楼，听刘老师说就是分讨，而且蒋老师分讨接近切 A，拜谢/bx/se。</p><p>讨论了一路关于二分单调性的东西，最终豆得出结论：$k$ 较大时有单调性，较小时没有，我恍然大悟。</p><p>回家吃了饭，下午还得去学校团建，累。</p><p>回家估分。A 比我预期低十分，但是该得的分挂了，不该得的分得了。B 暴力拿到了。</p><p>一问，一车写了 BC 更多部分分的，我是 shaber。</p><p>十点被逼迫睡觉了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>希望别漏下性质分。</p><p>八点多到的考场，打了缺省源就开始睡觉。</p><p>公布密码。一看，A 疑似太疑似了，看到 $\sum n \leq 80$，暴力分都不给了？去看 BC 结果发现更抽象，于是回来写 A 的 A 性质，写了一会发现过了。</p><p>去看了 B，草草把 B 的前 5pts 写了，输出 1 然后跑路去 C。C 这题面就不想看，跑路回 A，发现 A 的纯暴力能过，就写了 A 暴力。</p><p>然后看 B 性质。先想了一个非常贪的东西，写出来发现不行，然后就对着样例调。优先队列改成枚举，枚举改成优先队列，贪心思路来来回回改了不下十遍，样例三总是有几个数不对，但是样例四过了，样例五过不了。</p><p>A 一直写到了 12:50。出考场问一下，只有蒋老师把 A 前四个样例切了，用的是树剖套树套树，害怕，然后发现 B 都写了 20pts，崩溃了。</p><p>回家后发现 A 是 DP，以后贪不对的时候记得想想 DP。</p><p>笑，估分，A 比保底得分多了 10pts，没白贪。</p><h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day inf"></a>Day inf</h1><p>出分。$40 + 12 + 0 + 50 + 10 = 112$。</p><p>感觉挺唐诗的，D1T1<br>与我预期挂了 20pts，D2T1 挂了 -10pts。</p><p>排名 70 多，不忍心看。</p><p>崩溃。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/2024/04/02/Introduction/"/>
      <url>/2024/04/02/Introduction/</url>
      
        <content type="html"><![CDATA[<h1>这是一个自我介绍</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2024/04/02/Test/"/>
      <url>/2024/04/02/Test/</url>
      
        <content type="html"><![CDATA[<h1>This is a testing article.</h1><p>$$ 若a,b&gt;0，则 a+b \ge 2\sqrt{ab} $$</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
